###############################################
# 脚本中用到的数据类型为以下几类：
# int:		整数类型
# bool:		布尔类型(true 或者 false)
# string:	字符串
# function:	函数
# Card:		卡片类
# Effect:	效果类
# Group:	卡片组类
# table:	表类型
# nil:		空类型，也表示空的变量
# any:		任意类型
# 为方便说明，采用类似C的函数表示方法说明
# []表示有默认值可省略的参数
# 只说明有意义的nil类型参数或返回值
#
# 注：关于过滤条件函数
#  过滤条件函数是指第一个参数是Card类型，并且返回值是boolean的函数。此函数用于在一些获取满足条件的卡片组的过滤函数中重复调用。过滤条件函数可以有不定的参数，第二个开始的参数从过滤函数的额外参数获得。举例：
# function sample_filter(c, atk, def)
# 	return c:GetAttack()>=atk and c:GetDefense()>=def
# end
# 此函数对于一张卡c，如果攻击力>=atk并且守备力>=def则返回true，否则返回false
# g=Duel.GetFieldGroup(0,LOCATION_HAND,0) --获取玩家1的手卡
# fg=g:Filter(sample_filter,nil,1000,500) --从g中筛选攻击力>=1000并且守备>=500的卡
# Group.Filter只需要3个参数，第4个参数开始为额外参数，额外的参数会传给sample_filter
#
# 注：关于指定位置
# 一些函数可以获取指定位置的卡，通过三个参数指定 int player, int s, int o
# s指对玩家 player 来说的己方的位置，o指对玩家 player 来说的对方的位置
# 比如Duel.GetFieldGroup(0,LOCATION_GRAVE,LOCATION_MZONE)
# 返回玩家0墓地和玩家1的怪兽区的所有卡
#
# 注：关于描述
# 脚本系统并不是直接使用字符串显示提示文字，而是由系统通过一个整数(int desc)查找相应的描述
# 对于desc<2048，系统在string.conf里面寻找，其中一些常用的数字(通常是提示选择的文字)在constant.lua中有记录
# 对于desc>10000，系统在卡片数据库中寻找描述，通常使用aux.Stringid()函数指定
#
#●void Duel.ReplaceAttacker(Card c)
#用c代替当前攻击的卡进行伤害阶段（此函数已不存在）
#●void Duel.ReplaceAttackTarget(Card c)
#(预留）（函数不存在）
#
#●bool Duel.VenomSwampCheck(Effect e, Card c)
#蛇毒沼泽专用。把攻击力被其效果变成0的卡片破坏
#（函数不存在）
#
#对于Duel 类的函数，基本上都是player为0或1 以外的值的场合，返回false。
#
#区域相关：
#自己场上从左往右，序号依次是0~4，额外怪兽区是5~6，0x7f 则表示全部主怪兽区+额外怪兽区
#获取的区域值 zone 是以2位底，区号为次幂的数，所以要获取正确的区号，需要做对数 math.log(zone,2)
#涉及到对方的区域，则需要把对方的值 左移16位
#
#换成二进制比较好直观理解：（空格是为了方便分辨是第几位）
#
#0x7f= 0111 1111
#把它从低位开始 倒序排，就是  1111 1110 ，前5个就代表自己的5个主要怪兽区，第6个就是左边的额外怪兽区，第7个是右边的额外怪兽区
#(0)= 1  = 0x1 	= 0000 0001
#(1)= 2  = 0x2 	= 0000 0010
#(2)= 4  = 0x4 	= 0000 0100
#(3)= 8  = 0x8 	= 0000 1000
#(4)= 16 = 0x10 = 0001 0000
#(5)= 32 = 0x20 = 0010 0000
#(6)= 64 = 0x40 = 0100 0000
#
##############################################

●void initial_effect(Card c)
载入卡片时调用
一般是注册初始卡片效果，以及设置苏生限制等等
========== bit ===========
●bit库已删除，请用操作符操作，详见 utility.lua

========== Card ==========
●int[,int] Card.GetCode(Card c)
返回卡片 c 的当前卡号（可能因为效果改变）

●int Card.GetOriginalCode(Card c)
返回卡片 c 的卡片记载的卡号

●int[,int] Card.GetOriginalCodeRule(Card c)
返回卡片 c 规则上的代号（这张卡规则上当作XXX使用）

●int[,int,...] Card.GetFusionCode(Card c)
返回卡片 c 作为融合素材时的卡号。第2个返回值开始是其他的卡号

●int[,int,...] Card.GetLinkCode(Card c)
返回卡片 c 作为连接素材的卡号。第2个返回值开始是其他的卡号

●bool Card.IsFusionCode(Card c, int code[, ...])
检查卡片 c 作为融合素材时能否当作卡号为 code 的卡，额外参数是其他 code

●bool Card.IsLinkCode(Card c, int code[,...])
检查卡片 c 作为连接素材时能否当作卡号为 code 的卡，额外参数是其他 code

●bool Card.IsSetCard(Card c, int setname[, ...])
检查卡片 c 是否是卡名含有 setname 的卡(也就是字段)，额外参数是其他 setname

●bool Card.IsOriginalSetCard(Card c, int setname[, ...])
检查卡片 c 是否是原本卡名含有 setname 的卡(也就是字段)

●bool Card.IsPreviousSetCard(Card c, int setname[, ...])
检查卡片 c 位置变化之前是否是名字含有 setname 的卡(也就是字段)

●bool Card.IsFusionSetCard(Card c, int setname)
检查卡片 c 作为融合素材时能否当作名字含有 setname 的卡(也就是字段)

●bool Card.IsLinkSetCard(Card c, int setname)
检查卡片 c 作为连接素材时能否当作名字含有 setname 的卡(也就是字段)

●int Card.GetType(Card c)
返回卡片 c 的当前类型

●int Card.GetOriginalType(Card c)
返回卡片 c 的卡片记载的类型

●int Card.GetFusionType(Card c)
返回卡片 c 用作融合素材时的类型（与GetType的区别在于对于魔陷区的怪兽卡，返回其原本类型）

●int Card.GetSynchroType(Card c)
返回卡片 c 用作同调素材时的类型（与GetType的区别在于对于魔陷区的怪兽卡，返回其原本类型）

●int Card.GetXyzType(Card c)
返回卡片 c 用作同调素材时的类型（与GetType的区别在于对于魔陷区的怪兽卡，返回其原本类型）

●int Card.GetLinkType(Card c)
返回卡片 c 用作连接素材时的类型（与GetType的区别在于对于魔陷区的怪兽卡，返回其原本类型）

●int Card.GetLevel(Card c)
返回卡片 c 的当前等级

●int Card.GetRank(Card c)
返回卡片 c 的当前阶级

●int Card.GetLink(Card c)
返回卡片 c 的连接标记数量

●int Card.GetSynchroLevel(Card c, Card sc)
返回卡片 c 的对于同调怪兽 sc 的同调用等级
此函数除了某些特定卡如调节支援士，返回值与Card.GetLevel(c)相同

●int Card.GetRitualLevel(Card c, Card rc)
返回卡片 c 的对于仪式怪兽 rc 仪式解放等级
此函数除了某些特定卡如仪式供物，返回值与Card.GetLevel(c)相同

●int Card.GetOriginalLevel(Card c)
返回卡片 c 的卡片记载的等级

●int Card.GetOriginalRank(Card c)
返回卡片 c 的卡片记载的阶级

●bool Card.IsXyzLevel(Card c, Card xyzc, int lv)
检查卡片 c 对于超量怪兽 xyzc 的超量用等级是否是 lv

●int Card.GetLeftScale(Card c)
返回卡片 c 的左灵摆刻度

●int Card.GetOriginalLeftScale(Card c)
返回卡片 c 的原本的左灵摆刻度

●int Card.GetRightScale(Card c)
返回卡片 c 的右灵摆刻度

●int Card.GetOriginalRightScale(Card c)
返回卡片 c 的原本的右灵摆刻度

●int Card.GetCurrentScale(Card c)
返回卡片 c 的当前灵摆刻度
若 c 在左侧的灵摆区，则返回左灵摆刻度；否则返回右灵摆刻度

●bool Card.IsLinkMarker(Card c, int dir)
检查卡片 c 是否是连接标记为 dir 的卡
dir 的值有：
LINK_MARKER_BOTTOM_LEFT		=0x001 -- ↙
LINK_MARKER_BOTTOM			=0x002 -- ↓
LINK_MARKER_BOTTOM_RIGHT	=0x004 -- ↘
LINK_MARKER_LEFT			=0x008 -- ←
LINK_MARKER_RIGHT			=0x020 -- →
LINK_MARKER_TOP_LEFT		=0x040 -- ↖
LINK_MARKER_TOP				=0x080 -- ↑
LINK_MARKER_TOP_RIGHT		=0x100 -- ↗

●Group Card.GetLinkedGroup(Card c)
返回卡片 c 的连接区的卡片组（目前只限怪兽区）

●int Card.GetLinkedGroupCount(Card c)
返回卡片 c 的连接区的卡片组的卡的数量（目前只限怪兽区）

●int Card.GetLinkedZone(Card c[, int player=c:GetControler()])
返回卡片 c 的[以 player 来看的场上的]连接区域

●Group Card.GetMutualLinkedGroup(Card c)
返回和卡片 c 互相连接状态的卡片组

●int Card.GetMutualLinkedGroupCount(Card c)
返回和卡片 c 互相连接状态的卡片组的数量

●int Card.GetMutualLinkedZone(Card c[, int player=c:GetControler()])
返回[以 player 来看的]与卡片 c 互相连接的卡 所在的区域 

●bool Card.IsLinkState(Card c)
检查卡片 c 是否是连接状态

●bool Card.IsExtraLinkState(Card c)
检查卡片 c 是否是额外连接状态

●Group Card.GetColumnGroup(Card c)
返回与卡片 c 同一纵列的 c 以外的卡片组

●int Card.GetColumnGroupCount(Card c)
返回与卡片 c 同一纵列的 c 以外的卡片的数量

●int Card.GetColumnZone(Card c, int location[, int player=c:GetControler()])
返回[以 player 来看的] location 范围内与卡片 c 同一纵列的区域(c 所在的位置排除)，
location 的值是 LOCATION_MZONE,LOCATION_SZONE,LOCATIOIN_ONFIELD 
返回值是1个32位的2进制数
高16位是以 player 来看的对方的区域，其中前8位是魔法陷阱区域，后8位是怪兽区
低16位是以 player 来看的自己的区域，其中前8位是魔法陷阱区域，后8位是怪兽区
比如 卡片 c 处于自己主要怪兽区左数第2个格子，那么 c:GetColumnZone(LOCATIOIN_ONFIELD) 的结果为
0000 1000 0100 1000  --对方的区域
0000 0010 0010 0000  --自己的区域

●bool Card.IsAllColumn(Card c)
检查与卡片 c 同一纵列的区域是否全都有卡

●int Card.GetAttribute(Card c)
返回卡片 c 的当前属性
注：对某些多属性怪兽如光与暗之龙，此函数的返回值可能是几个属性的组合值

●int Card.GetOriginalAttribute(Card c)
返回卡片 c 的卡片记载的属性

●int Card.GetFusionAttribute(Card c[, int player=PLAYER_NONE])
返回卡片 c [由 player 融合召唤时]用作融合素材时的属性

●int Card.GetLinkAttribute(Card c[, int player=PLAYER_NONE])
返回卡片 c [由 player 连接召唤时]用作连接素材时的属性

●int Card.GetRace(Card c)
返回卡片 c 的当前种族
注：对某些多种族怪兽如动画效果的魔术猿，此函数的返回值可能是几个种族的组合值

●int Card.GetOriginalRace(Card c)
返回卡片 c 的卡片记载的种族

●int Card.GetLinkRace(Card c[, int player=PLAYER_NONE])
返回卡片 c [由 player 连接召唤时]作为连接素材时的种族

●int Card.GetAttack(Card c)
返回卡片 c 的当前攻击力

●int Card.GetBaseAttack(Card c)
返回卡片 c 的原本攻击力

●int Card.GetTextAttack(Card c)
返回卡片 c 的卡片记载的攻击力，返回值是负数表示是"?"

●int Card.GetDefense(Card c)
返回卡片 c 的当前守备力

●int Card.GetBaseDefense(Card c)
返回卡片 c 的原本守备力

●int Card.GetTextDefense(Card c)
返回卡片 c 的卡片记载的守备力，返回值是负数表示是"?"

●int[,int] Card.GetPreviousCodeOnField(Card c)
返回卡片 c 位置变化之前在场上的卡号

●int Card.GetPreviousTypeOnField(Card c)
返回卡片 c 位置变化之前在场上的类型

●int Card.GetPreviousLevelOnField(Card c)
返回卡片 c 位置变化之前在场上的等级

●int Card.GetPreviousRankOnField(Card c)
返回卡片 c 位置变化之前在场上的阶级

●int Card.GetPreviousAttributeOnField(Card c)
返回卡片 c 位置变化之前在场上的属性

●int Card.GetPreviousRaceOnField(Card c)
返回卡片 c 位置变化之前在场上的种族

●int Card.GetPreviousAttackOnField(Card c)
返回卡片 c 位置变化之前在场上的攻击力

●int Card.GetPreviousDefenseOnField(Card c)
返回卡片 c 位置变化之前在场上的守备力

●int Card.GetOwner(Card c)
返回卡片 c 的持有者

●int Card.GetControler(Card c)
返回卡片 c 的当前控制者

●int Card.GetPreviousControler(Card c)
返回卡片 c 的位置变化之前的控制者

●int Card.GetReason(Card c)
返回卡片 c 的位置变化原因

●Card Card.GetReasonCard(Card c)
返回导致卡片 c 的位置变化的卡
此函数仅在某卡被战斗破坏时，因为上级召唤被解放，或者成为特殊召唤使用的素材时有效

●int Card.GetReasonPlayer(Card c)
返回导致卡片 c 的位置变化的玩家

●Effect Card.GetReasonEffect(Card c)
返回导致卡片 c 的位置变化的效果

●int Card.GetPosition(Card c)
返回卡片 c 当前的表示形式

●int Card.GetPreviousPosition(Card c)
返回卡片 c 位置变化前的表示形式

●int Card.GetBattlePosition(Card c)
返回卡片 c 在本次战斗发生之前的表示形式

●int Card.GetLocation(Card c)
返回卡片 c 当前的所在位置

●int Card.GetPreviousLocation(Card c)
返回卡片 c 位置变化前的所在的位置

●int Card.GetSequence(Card c)
返回卡片 c 在当前位置的序号
在场上时，序号代表所在的格子，从左往右分别是0-4，5-6，场地魔法格的序号为5，左右灵摆区域为6-7
在其它地方时，序号表示的是第几张卡，最下面的卡的序号为0

●int Card.GetPreviousSequence(Card c)
返回卡片 c 位置变化前的序号
在场上时，序号代表所在的格子，从左往右分别是0-4，5-6，场地魔法格的序号为5，左右灵摆区域为6-7
在其它地方时，序号表示的是第几张卡，最下面的卡的序号为0

●int Card.GetSummonType(Card c)
返回卡片 c 的召唤/特殊召唤的方式

●int Card.GetSummonLocation(Card c)
返回卡片 c 的召唤/特殊召唤的位置

●int Card.GetSummonPlayer(Card c)
返回召唤/特殊召唤 c 上场的玩家

●int Card.GetDestination(Card c)
返回卡片 c 位置变化的目的地
此函数仅在处理位置转移代替效果时有效

●int Card.GetLeaveFieldDest(Card c)
返回卡片 c 离场时因改变去向的效果（如大宇宙）的目的地

●int Card.GetTurnID(Card c)
返回卡片 c 转移到当前位置的回合

●int Card.GetFieldID(Card c)
返回卡片 c 转移到当前位置的时间标识
此数值唯一，越小表示c是越早出现在那个位置
卡片从里侧翻开也会改变此数值

●int Card.GetRealFieldID(Card c)
返回卡片 c 转移到当前位置的真实的时间标识
卡片从里侧翻开不会改变此数值

●bool Card.IsOriginalCodeRule(Card c, int code1[, int code2,...])
检查卡片 c 的卡号是否规则上（就是CDB里显示的卡密）是 code1[, 或者为 code2...]

●bool Card.IsCode(Card c, int code1[, int code2,...])
检查卡片 c 的卡号是否是 code1[, 或者为 code2...]

●bool Card.IsType(Card c, int type)
检查卡片 c 是否属于类型 type

●bool Card.IsFusionType(Card c, int type)
检查卡片 c 用作融合素材时是否属于类型 type （与IsType的区别在于对于魔陷区的怪兽卡，用其原本类型作判断）

●bool Card.IsSynchroType(Card c, int type)
检查卡片 c 用作同调素材时是否属于类型 type （与IsType的区别在于对于魔陷区的怪兽卡，用其原本类型作判断）

●bool Card.IsXyzType(Card c, int type)
检查卡片 c 用作超量素材时是否属于类型 type （与IsType的区别在于对于魔陷区的怪兽卡，用其原本类型作判断）

●bool Card.IsLinkType(Card c, int type)
检查卡片 c 用作连接素材时是否属于类型 type （与IsType的区别在于对于魔陷区的怪兽卡，用其原本类型作判断）

●bool Card.IsLevel(Card c, int level1[, int level2,...])
检查卡片 c 是否是等级 level1[, 或者为 level2...]

●bool Card.IsRank(Card c, int rank1[, int rank2,...])
检查卡片 c 是否是阶级 rank1[, 或者为 rank2...]

●bool Card.IsLink(Card c, int link1[, int link2,...])
检查卡片 c 的连接标记数量是否是 link1[, 或者为 link2...]

●bool Card.IsAttack(Card c, int atk1[, int atk2,...])
检查卡片 c 的攻击力是否是 atk1[, 或者为 atk2...]，如果c不是怪兽卡，或者不在 LOCATION_MZONE 则都返回false

●bool Card.IsDefense(Card c, int def[, int atk2,...])
检查卡片 c 的守备力是否是 def1[, 或者为 def2...]，如果c不是怪兽卡，或者不在 LOCATION_MZONE 则都返回false

●bool Card.IsRace(Card c, int race)
检查卡片 c 是否属于种族 race

●bool Card.IsLinkRace(Card c, int race[, int player=PLAYER_NONE])
检查卡片 c [由 player 连接召唤时]用作连接素材时是否属于种族 race

●bool Card.IsAttribute(Card c, int attribute)
检查卡片 c 是否属于属性 attribute

●bool Card.IsFusionAttribute(Card c, int attribute[, int player=PLAYER_NONE])
检查卡片 c [由 player 融合召唤时]用作融合素材是否属于属性 attribute

●bool Card.IsLinkAttribute(Card c, int attribute[, int player=PLAYER_NONE])
检查卡片 c [由 player 连接召唤时]用作连接素材是否属于属性 attribute

●bool Card.IsExtraDeckMonster(Card c)
检查卡片 c 是否属于额外卡组的怪兽(融合·同调·超量·连接)

●bool Card.IsReason(Card c, int reason)
检查卡片 c 是否包含原因 reason

●bool Card.IsSummonType(Card c, int sumtype)
检查卡片 c 的召唤类型是否是 sumtype

●bool Card.IsSummonLocation(Card c, int tloc)
检查卡片 c 的召唤区域是否是 tloc

●bool Card.IsSummonPlayer(Card c, int sumplayer)
检查卡片 c 的召唤玩家是否是 sumplayer

●bool Card.IsStatus(Card c, int status)
检查卡片 c 是否包含某个状态码 status

●bool Card.IsNotTuner(Card c, Card sc)
检查卡片 c 是否可以作为同调怪兽 sc 的调整以外的怪兽

●void Card.SetStatus(Card c, int state, bool enable)
给卡片 c 设置或者取消状态码
除非妳清楚的了解每个状态码的含意，否则不要轻易使用此函数

●bool Card.IsDualState(Card c)
检查卡片 c 属否处于再召唤状态

●void Card.EnableDualState(Card c)
把卡片 c 设置成再召唤状态

●void Card.SetTurnCounter(Card c, int ct)
设置卡片 c 的回合计数器为 ct （光之护封剑、异国的剑士等）

●int Card.GetTurnCounter(Card c)
返回卡片 c 的回合计数器

●void Card.SetMaterial(Card c, nil|Group g)
把卡片组 g 中的所有卡作为卡片 c 的素材（上级召唤，特殊召唤）
第二个参数如果传入 nil ,是把卡片 c 的素材清除

●Group Card.GetMaterial(Card c)
返回卡片 c 出场使用的素材

●int Card.GetMaterialCount(Card c)
返回卡片 c 出场使用的素材数量

●Group Card.GetEquipGroup(Card c)
返回卡片 c 当前装备着的卡片组

●int Card.GetEquipCount(Card c)
返回卡片 c 当前装备着的卡片数量

●Card Card.GetEquipTarget(Card c)
返回卡片 c 当前的装备对象

●Card Card.GetPreviousEquipTarget(Card c)
返回卡片 c 之前的装备对象

●bool Card.CheckEquipTarget(Card c1, Card c2)
检查卡片 c2是否是卡片 c1 的正确的装备对象
##由 EFFECT_EQUIP_LIMIT 效果或同盟状态确定

●bool Card.CheckUnionTarget(Card c1, Card c2)
检查卡片 c2 是否是卡片 c1 的正确的同盟对象
##由 EFFECT_UNION_LIMIT 效果确定

●int,int Card.GetUnionCount(Card c)
返回卡片 c 当前装备的同盟卡数量
第二个返回值是 旧同盟 的数量 

●Group Card.GetOverlayGroup(Card c)
返回卡片 c 当前叠放着的卡片组

●int Card.GetOverlayCount(Card c)
返回卡片 c 当前叠放着的卡片数量

●Card Card.GetOverlayTarget(Card c)
返回以卡片 c 为超量素材的卡

●bool Card.CheckRemoveOverlayCard(Card c, int player, int count, int reason)
检查玩家 player 能否以 reason 为原因，至少取除卡片 c 下面叠放的 count 张卡

●int Card.RemoveOverlayCard(Card c, int player, int minc, int maxc, int reason)
以 reason 为原因，让玩家 player 取除卡片 c 下面叠放的 minc-maxc 张卡，返回值表示取除的数量

●Group Card.GetAttackedGroup(Card c)
返回卡片 c 本回合攻击过的卡片组

●int Card.GetAttackedGroupCount(Card c)
返回卡片 c 本回合攻击过的卡片数量

●int Card.GetAttackedCount(Card c)
返回卡片 c 本回合攻击过的次数
注：如果此值与 Card.GetAttackedGroupCount(c) 的返回值不同，那么说明卡片c本回合进行过直接攻击

●Group Card.GetBattledGroup(Card c)
返回本回合与卡片 c 进行过战斗的卡片组
进行过战斗指发生过伤害的计算，用于剑斗兽等卡的判定

●int Card.GetBattledGroupCount(Card c)
返回本回合与卡片 c 进行过战斗的的卡片数量

●int Card.GetAttackAnnouncedCount(Card c)
返回卡片 c 本回合攻击宣言的次数
注：攻击被无效不会被计入攻击过的次数，但是会计入攻击宣言的次数

●bool Card.IsDirectAttacked(Card c)
检查卡片 c 是否直接攻击过

●void Card.SetCardTarget(Card c1, Card c2)
把卡片 c2 作为卡片 c1 的永续对象
c1 和 c2 的联系会在 c1 或 c2 任意一卡离场或变成里侧表示时重置

●Group Card.GetCardTarget(Card c)
返回卡片 c 当前所有的永续对象

●Card Card.GetFirstCardTarget(Card c)
返回卡片 c 当前第一个永续对象，没有则返回 nil

●int Card.GetCardTargetCount(Card c)
返回卡片 c 当前的永续对象的数量

●bool Card.IsHasCardTarget(Card c1, Card c2)
检查卡片 c2 是否取卡片 c1 为永续对象

●void Card.CancelCardTarget(Card c1, Card c2)
取消卡片 c2 为 c1 的永续对象

●Group Card.GetOwnerTarget(Card c)
返回取卡片 c 作为永续对象的所有卡

●int Card.GetOwnerTargetCount(Card c)
返回取卡片 c 作为永续对象的卡的数量

●Effect,... Card.GetActivateEffect(Card c)
返回卡片 c 的“卡片发动”的效果，即类型为EFFECT_TYPE_ACTIVATE的效果
仅对魔法和陷阱有效。对于多个卡片发动的效果的卡(比如 神之宣告)，会全部返回

●Effect[,Group,int,int,Effect,int,int] Card.CheckActivateEffect(Card c, bool neglect_con, bool neglect_cost, bool copy_info)
返回卡片 c 的可以发动时机正确的“卡的发动”的效果，neglect_con==true 则无视发动条件，neglect_cost==true 则无视发动cost
copy_info==false 或者自由时点的效果则只返回这个效果 e
否则还返回这个效果的触发时点的信息 e,eg,ep,ev,re,r,rp

●void|Effect[,function,int,int,int] Card.GetTunerLimit(Card c)
如果卡片 c 受到同调素材限制效果 EFFECT_TUNER_MATERIAL_LIMIT 影响，则返回 Effect e,function filter_target,int location,int min,int max ;否则返回nil
e 是有这个影响的效果
filter_target 是过滤条件
location 是位置
min,max 是数量
min 默认值是 0 ，max 默认值是 99
意思大概是： 这张卡作为同调素材的场合，其他卡要是 满足条件 filter_target 位置是 location 数量为 minc-maxc 的卡
返回值大概等同于下面这个效果对应名字参数的值(参考对象<极星灵 黑精灵>)：
local e=Effect.CreateEffect(c)
e:SetType(EFFECT_TYPE_SINGLE)
e:SetCode(EFFECT_TUNER_MATERIAL_LIMIT)
e:SetProperty(EFFECT_FLAG_CANNOT_DISABLE+EFFECT_FLAG_UNCOPYABLE+EFFECT_FLAG_SPSUM_PARAM)
e:SetTarget(function (e,c1)return filter_target(c1) end)
e:SetTargetRange(min,max)
e:SetValue(location)
c:RegisterEffect(e)

●void|Effect[,function,int,int] Card.GetHandSynchro(Card c)
如果卡片 c 受到手卡同调效果 EFFECT_HAND_SYNCHRO 影响，则返回 Effect e,function filter_target,int min,int max ;否则返回nil
e 是有这个影响的效果
filter_target 是过滤条件
min,max 是数量
min 默认值是 0 ，max 默认值是 99
意思大概是： 这张卡作为同调素材的场合，其他卡要是 满足条件 filter_target 数量为 minc-maxc 的手卡
返回值大概等同于下面这个效果对应名字参数的值(参考对象<极星灵 黑精灵>)：
local e=Effect.CreateEffect(c)
e:SetType(EFFECT_TYPE_SINGLE)
e:SetCode(EFFECT_TUNER_MATERIAL_LIMIT)
e:SetProperty(EFFECT_FLAG_CANNOT_DISABLE+EFFECT_FLAG_UNCOPYABLE+EFFECT_FLAG_SPSUM_PARAM)
e:SetTarget(function (e,c1)return filter_target(c1) end)
e:SetTargetRange(min,max)
e:SetValue(LOCATION_HAND)
c:RegisterEffect(e)

●int Card.RegisterEffect(Card c, Effect e[, bool forced=false])
把效果 e 注册给卡片 c ，返回效果的全局id，并设置 e 的 Handler 为 c
默认情况下注册时如果 c 带有免疫 e 的效果那么注册会失败
如果 forced==true 则不会检查卡片 c 对e的免疫效果

●... Card.IsHasEffect(Card c, int code[, int check_player=PLAYER_NONE])
检查卡片 c 是否受到效果种类是code的效果的影响
没有则返回nil
有则返回那些效果

●void Card.ResetEffect(Card c, int reset_code, int reset_type)
以重置类型为 reset_type 、重置种类为 reset_code 手动重置卡片 c 受到的效果的影响
reset_type 只能是以下类型，对应的重置种类为
RESET_EVENT       发生事件重置        reset_code为事件
RESET_PHASE       阶段结束重置        reset_code为阶段
RESET_CODE        重置指定code的效果  reset_code为效果的种类code，只能重置EFFECT_TYPE_SINGLE的永续型效果
RESET_COPY        重置复制的效果      reset_code为copy_id
RESET_CARD        重置卡片的效果      reset_code为效果owner的卡号

●int Card.GetEffectCount(Card c, int code)
返回卡片 c 受到影响的种类是code的效果的数量

●Effect Card.RegisterFlagEffect(Card c, int code, int reset_flag, int property, int reset_count[, int label, int desc])
为卡片 c 注册一个标识用效果
效果代码为 code  ，描述为 desc ，标签为 label ，这个效果会在达到 reset_count 次 reset_flag 时点重置， property 一般写0即可
注：注册给卡的标识用效果不会用于系统，
即使 code 与内置效果 code 重合也不会影响，
并且类型总是 EFFECT_TYPE_SINGLE，reset 方法，property 和一般的效果相同，
并且不会无效化，不受卡的免疫效果影响

●int Card.GetFlagEffect(Card c, int code)
返回卡片 c 的种类是 code 的标识效果的数量

●void Card.ResetFlagEffect(Card c, int code)
手动清除卡片 c 的种类是 code 的标识效果

●bool Card.SetFlagEffectLabel(Card c, int code, int label)
返回卡片 c 是否存在种类为 code 的标识效果，若存在则设置其Label属性为 label (如果已经有Label ，则会清除原本的Label)

●int[,...] Card.GetFlagEffectLabel(Card c, int code)
返回卡片 c 的种类为 code 的标识效果的Label(数量可能不止1个)，没有此效果则返回nil

●void Card.CreateRelation(Card c1, Card c2, int reset_flag)
为卡片 c1 建立与卡片 c2 的联系，此联系仅会由于 c1 发生 RESET_EVENT 的事件重置

●void Card.ReleaseRelation(Card c1, Card c2)
手动释放卡片 c1 对于卡片 c2 的联系

●void Card.CreateEffectRelation(Card c, Effect e)
为卡片 c 和效果 e 建立联系

●void Card.ReleaseEffectRelation(Card c, Effect e)
手动释放卡片 c 与效果 e 的联系

●void Card.ClearEffectRelation(Card c)
清空卡片 c 所有效果联系

●bool Card.IsRelateToEffect(Card c, Effect e)
检查卡片 c 是否和效果 e 有联系
注：每次发动进入连锁的效果时，发动效果的卡，以及发动效果时指定的对象
（用Duel.SetTargetCard或者Duel.SelectTarget指定的，包括取对象和不取对象）
会自动与那个效果建立联系，一旦离场，联系会重置

●bool Card.IsRelateToChain(Card c, int chainc)
检查卡片 c 是否和连锁 chainc 有联系。 chainc==0 表示当前连锁

●bool Card.IsRelateToCard(Card c1, Card c2)
检查卡片 c1 是否和卡片 c2 有联系

●bool Card.IsRelateToBattle(Card c)
检查卡片 c 是否和本次战斗关联
注：此效果通常用于伤害计算后伤害阶段结束前，用于检查战斗的卡是否离场过

●int Card.CopyEffect(Card c, int code, int reset_flag[, int reset_count=1])
为卡片 c 添加卡号是 code 的卡的可复制的效果，并且添加额外的重置条件，那些效果会在 reset_count 次 reset_flag 时点后重置
返回值是表示复制效果的代号id

●int Card.ReplaceEffect(Card c, int code, int reset_flag[, int reset_count=1])
把卡片 c 的效果替换为卡号是 code 的卡的效果，并且添加额外的重置条件，那些效果会在 reset_count 次 reset_flag 时点后重置
返回值是表示替换效果的代号id

●void Card.EnableReviveLimit(Card c)
为卡片 c 添加苏生限制
等价于：
local e1=Effect.CreateEffect(c)
e1:SetType(EFFECT_TYPE_SINGLE)
e1:SetCode(EFFECT_REVIVE_LIMIT)
e1:SetProperty(EFFECT_FLAG_CANNOT_DISABLE+EFFECT_FLAG_UNCOPYABLE)
c:RegisterEffect(e1)

●void Card.CompleteProcedure(Card c)
使c完成正规的召唤手续
##此函数也可通过 c:SetStatus(STATUS_PROC_COMPLETE,true)实现

●bool Card.IsDisabled(Card c)
检查卡片 c 是否处于无效状态

●bool Card.IsDestructable(Card c[, Effect e])
检查卡片 c 是否是可被[效果 e]破坏的

●bool Card.IsSummonableCard(Card c)
检查卡片 c 是否是可通常召唤的卡

●bool Card.IsFusionSummonableCard(Card c[, int sum_type])
检查卡片 c 是否是可[用 sum_type 方式]融合召唤的卡

●bool Card.IsSpecialSummonable(Card c[, int sum_type])
检查是否可以对卡片 c [用 sum_type 方式]进行特殊召唤手续

●bool Card.IsSynchroSummonable(Card c ,Card tuner|nil[, Group mg, int minc=0, int maxc=0])
检查是否可以以卡片 tuner 作为调整，用场上[或 mg 中][minc ~ maxc 张]的卡为同调素材对卡片 c 进行同调召唤手续
c 如果不是同调会返回 false

●bool Card.IsXyzSummonable(Card c, Group mg|nil[, minc=0, maxc=0])
检查是否可以在场上的卡[或 mg][中选出 minc-maxc 个超量素材]对卡片 c 进行超量召唤手续
c 如果不是超量会返回 false

●bool Card.IsLinkSummonable(Card c, Group mg|nil[, Card lcard, minc=0, maxc=0])
检查是否可以用[包含卡 lcard 的]场上[或 mg 中]的卡[选出 minc-maxc 个连接素材]对卡片 c 进行连接召唤手续
c 如果不是连接会返回 false

●bool Card.IsSummonable(Card c, bool ignore_count, Effect e|nil[, int minc=0, int zone=0x1f])
检查卡片 c 是否可以进行通常召唤（不包含通常召唤的set)，ignore_count==true 则不检查召唤次数限制
e~=nil 则检查卡片 c 是否可以以效果 e 进行通常召唤，minc 表示至少需要的祭品数（用于区分妥协召唤与上级召唤）,zone 表示必须要召唤到的区域

●bool Card.IsMSetable(Card, bool ignore_count, Effect e|nil[, int minc=0, int zone=0x1f])
检查卡片 c 是否可进行通常召唤的set，ignore_count==true 则不检查召唤次数限制
e~=nil 则检查卡片 c 是否可以以效果 e 进行通常召唤的set，minc 表示至少需要的祭品数（用于区分妥协召唤set与上级召唤set）,zone 表示必须要放置到的区域

●bool Card.IsSSetable(Card c[, bool ignore_field=false])
检查卡片 c 是否可以set到魔法陷阱区，ignore_field==true 则无视魔陷区格子是否能使用的限制

●bool Card.IsCanBeSpecialSummoned(Card c, Effect e, int sumtype, int sumplayer, bool nocheck, bool nolimit[, int sumpos=POS_FACEUP, int toplayer=sumplayer, int zone=0xff])
检查卡片 c 是否可以被玩家 sumplayer 用效果 e[以 sumtype 方式和 sumpos 表示形式]特殊召唤[到玩家 toplayer 的区域 zone]
如果 nocheck==true 则不检查卡片 c 的召唤条件，如果 nolimit==true 则不检查卡片 c 的苏生限制

●bool Card.IsAbleToHand(Card c[, int player=c:GetOwner()])
检查卡片 c 是否可以送去[玩家 player 的]手牌
注：仅当卡片或者玩家受到“不能加入手牌”的效果的影响时（如雷王）此函数才返回false
##以下几个函数类似

●bool Card.IsAbleToDeck(Card c)
检查卡片 c 是否可以送去卡组

●bool Card.IsAbleToExtra(Card c)
检查卡片 c 是否可以送去额外卡组
对于非融合、同调等额外怪兽或者非灵摆怪兽此函数均返回false

●bool Card.IsAbleToGrave(Card c)
检查卡片 c 是否可以送去墓地

●bool Card.IsAbleToRemove(Card c[, int player, int pos=POS_FACEUP, int reason=REASON_EFFECT])
检查卡片 c 是否可以被[玩家 player 以 pos 的表示形式,reason 原因]除外

●bool Card.IsAbleToHandAsCost(Card c)
检查卡片 c 是否可以作为cost送去手牌
注：此函数会在Card.IsAbleToHand的基础上追加检测c的实际目的地
当c送往手牌会被送去其它地方时（如缩退回路适用中，或者c是融合、同调 等额外怪兽的一种），此函数返回false
##以下几个函数类似

●bool Card.IsAbleToDeckAsCost(Card c)
检查卡片 c 是否可以作为cost送去卡组

●bool Card.IsAbleToExtraAsCost(Card c)
检查卡片 c 是否可以作为cost送去额外卡组，主卡组的灵摆卡会返回false

●bool Card.IsAbleToDeckOrExtraAsCost(Card c)
检查卡片 c 是否可以作为cost送去卡组或额外卡组（用于新宇侠、剑斗兽融合怪兽的召唤手续检测）
等价于 (c:IsAbleToDeckAsCost() or c:IsAbleToExtraAsCost())

●bool Card.IsAbleToGraveAsCost(Card c)
检查卡片 c 是否可以作为cost送去墓地

●bool Card.IsAbleToRemoveAsCost(Card c[, int pos=POS_FACEUP])
检查卡片 c 是否可以[以 pos 表示形式]作为cost除外

●bool Card.IsReleasable(Card c)
检查卡片 c 是否可以被解放（非上级召唤用）
如果 c 满足以下条件，都会返回 false
召唤(广义的)之际、 在墓地或者除外、 在手卡并且是魔法·陷阱、 玩家受到不能把卡解放的效果影响、 不能做上级召唤以外的祭品

●bool Card.IsReleasableByEffect(Card c)
检查卡片 c 是否可以被效果解放

●bool Card.IsDiscardable(Card[, int reason=REASON_COST])
检查卡片 c 是否可以以 reason 原因丢弃
注：此函数仅用于检测，
以 REASON_DISCARD 作为原因把一张手卡送墓并不会导致那张卡不能丢弃

●bool Card.IsAttackable(Card c)
检查卡片 c 是否可以攻击

●bool Card.IsChainAttackable(Card c[, int ac = 2, bool monsteronly = false])
检查卡片 c 是否可以连续攻击，c 的攻击宣言次数>=ac 则返回false
monsteronly==true 则表示只能对怪兽攻击
注：当 c 因为闪光之双剑等效果进行过多次攻击，并且 ac==2 的时候此函数返回false

●bool Card.IsFaceup(Card c)
检查卡片 c 是否是表侧表示

●bool Card.IsAttackPos(Card c)
检查卡片 c 是否是攻击表示

●bool Card.IsFacedown(Card c)
检查卡片 c 是否是里侧表示

●bool Card.IsDefensePos(Card c)
检查卡片 c 是否是守备表示

●bool Card.IsPosition(Card c, int pos)
检查卡片 c 是否是表示形式 pos

●bool Card.IsPreviousPosition(Card c, int pos)
检查卡片 c 位置变化之前是否是表示形式 pos

●bool Card.IsControler(Card c, int controler)
检查卡片 c 的当前控制着是否是 controler

●bool Card.IsPreviousControler(Card c, int controler)
检查卡片 c 位置变化之前的控制着是否是 controler

●bool Card.IsOnField(Card c)
检查卡片 c 是否在场
注：当怪兽召唤，反转召唤，特殊召唤时召唤成功之前，此函数返回false

●bool Card.IsLocation(Card c, int location)
检查卡片 c 当前位置是否是 location
注：location==LOCATION_MZONE 时，怪兽召唤(广义的)之际或被无效会返回 false
location==LOCATION_SZONE 时，魔陷发动无效会返回false

●bool Card.IsPreviousLocation(Card c, int location)
检查卡片 c 之前的位置是否是 location

●bool Card.IsLevelBelow(Card c, int level)
检查卡片 c 是否是等级 level 以下（至少为1）

●bool Card.IsLevelAbove(Card c, int level)
检查卡片 c 是否是等级 level 以上

●bool Card.IsRankBelow(Card c, int rank)
检查卡片 c 是否是阶级 rank 以下（至少为1）

●bool Card.IsRankAbove(Card c, int rank)
检查卡片 c 是否是阶级 rank 以上

●bool Card.IsLinkBelow(Card c, int link)
检查卡片 c 是否连接标记数量是 link 以下（至少为1）

●bool Card.IsLinkAbove(Card c, int link)
检查卡片 c 是否连接标记数量是 link 以上

●bool Card.IsAttackBelow(Card c, int atk)
检查卡片 c 是否是攻击力 atk 以下（至少为0）

●bool Card.IsAttackAbove(Card c, int atk)
检查卡片 c 是否是攻击力 atk 以上

●bool Card.IsDefenseBelow(Card c, int def)
检查卡片 c 是否是守备力 def 以下（至少为0）

●bool Card.IsDefenseAbove(Card c, int def)
检查卡片 c 是否是守备力 def 以上

●bool Card.IsPublic(Card c)
检查卡片 c 是否处于公开状态

●bool Card.IsForbidden(Card c)
检查卡片 c 是否处于被宣言禁止状态

●bool Card.IsAbleToChangeControler(Card c)
检查卡片 c 是否可以改变控制权
注：仅当卡收到了“不能改变控制权”的效果的影响时，此函数返回false

●bool Card.IsControlerCanBeChanged(Card c[, bool ignore_mzone=false, int zone=0xff])
检查卡片 c 的控制权是否可以改变。 ignore_mzone==true 会忽视转移控制权后的玩家场上是否有空格位， zone 表示必须要使用的位置

●bool Card.AddCounter(Card c, int countertype, int count[, bool singly=false])
为卡片 c 放置 count 个 countertype 类型的指示物，singly==true 表示逐个添加至 count 个为止

●void Card.RemoveCounter(Card c, int player, int countertype, int count, int reason)
让玩家 player 以原因 reason 移除卡片 c 上的 count 个 countertype 类型的指示物， countertype==0 则清除c的所有指示物,否则返回是否成功

●int Card.GetCounter(Card c, int countertype)
返回卡片 c 上的 countertype 类型的指示物的数量， countertype==0 则返回卡片 c 上所有类型的指示物数量之和

●void Card.EnableCounterPermit(Card c, int countertype[, int prange, function confilter])
允许卡片 c [在位置 prange 的场合，在满足条件 confilter 的情况下]被放置需要“可以放置”才能放置的指示物 countertype (参考对象：暗黑女武神<83269557>)
prange 的默认值与 c 的种类有关，灵摆怪兽需要指定能否在怪兽区域或灵摆区域放置指示物
等价于：
local e1=Effect.CreateEffect(c)
e1:SetType(EFFECT_TYPE_SINGLE)
e1:SetProperty(EFFECT_FLAG_SINGLE_RANGE)
e1:SetCode(EFFECT_COUNTER_PERMIT|countertype)
e1:SetCondition(confilter(e) end)
e1:SetRange(prange)
c:RegisterEffect(e1)

●void Card.SetCounterLimit(Card c, int countertype, int count)
设定卡片 c 放置 countertype 类型指示物的上限为 count

●bool Card.IsCanChangePosition(Card c)
检查卡片 c 是否可以用效果改变表示形式

●bool Card.IsCanTurnSet(Card c)
检查卡片 c 是否可以转成里侧表示

●bool Card.IsCanAddCounter(Card c, int countertype, int count[, int singly=false, int location])
检查是否可以给[在 location 区域存在的]卡片 c [逐个(singly==true)]放置 count 个 countertype 类型的指示物

●bool Card.IsCanRemoveCounter(Card c, int player, int countertype, int count, int reason)
检查玩家 player 是否可以以原因 reason 移除卡片 c 上的 count 个 countertype 类型的指示物

●bool Card.IsCanHaveCounter(Card c, int countertype)
检查卡片 c 是否可以放置 countertype 类型的指示物

●bool Card.IsCanOverlay(Card c[, int player=c:GetOwner()])
检查卡片 c 是否可以被[玩家 player]叠放
衍生物、不在场上的卡或者是被禁止的卡、不是玩家 player 的卡并且不会被改变控制权的卡 都会返回false

●bool Card.IsCanBeFusionMaterial(Card c[, Card fc, int summon_type=SUMMON_TYPE_FUSION])
检查卡片 c 是否可以成为[融合怪兽 fc 的 summon_type 方式的]融合素材

●bool Card.IsCanBeSynchroMaterial(Card c[, Card sc, Card tuner])
检查卡片 c 是否可以成为[以 tuner 为调整的同调怪兽 sc 的]同调素材

●bool Card.IsCanBeRitualMaterial(Card c, Card sc|nil)
检查卡片 c 是否可以作为[仪式怪兽 sc 的]仪式素材,没有指定sc的场合，必须填nil

●bool Card.IsCanBeXyzMaterial(Card c, Card sc|nil)
检查卡片 c 是否可以成为[超量怪兽 sc 的]超量素材,没有指定sc的场合，必须填nil

●bool Card.IsCanBeLinkMaterial(Card c, Card sc|nil)
检查卡片 c 是否可以成为[连接怪兽 sc 的]连接素材,没有指定sc的场合，必须填nil

●bool Card.CheckFusionMaterial(Card c[, Group mg|nil, Card gc|nil, int chkf=PLAYER_NONE, bool not_material=false])
检查场上[或 mg 中]是否包含了卡片 c 需要[必须包含卡片 gc 在内]的一组融合素材
not_material==true 则即使有素材原本不能作为 c 的融合素材，也能判定为那些素材可以凑齐一组 c 的融合素材
(参考对象：融合解除<95286165>，固定音型<9113513>，团结的剑斗兽<66290900>，奇迹接触<35255456>，新宇融合<14088859>)
##根据 c 的种类为 EFFECT_FUSION_MATERIAL 的效果的 Condition 函数检查

●bool Card.CheckFusionSubstitute(Card c, Card fc)
检查卡片 c 能否代替融合怪兽 fc 的记述卡名的素材

●bool Card.IsImmuneToEffect(Card c, Effect e)
检查卡片 c 是否免疫效果 e(即不受效果 e 的影响)

●bool Card.IsCanBeEffectTarget(Card c[, Effect e])
检查卡片 c 是否可以成为效果[e 的]对象

●bool Card.IsCanBeBattleTarget(Card c1, Card c2)
检查卡片 c1 是否可以成为卡片 c2 的攻击目标

●void Card.AddMonsterAttribute(Card c, int type[, int attribute, int race, int level, int atk, int def])
为魔陷卡 c 添加怪兽数值,type 为怪兽类型，不能是没有等级的怪兽
注：在数据库中有记录的数值视为原本数值
不再需要 Card.AddMonsterAttributeComplete(Card c)

●void Card.CancelToGrave(Card c[, bool cancel=true])
取消送墓确定状态，cancel==false 则重新设置送墓确定状态
注：送墓确定状态指的是在场上发动的不留场的魔法和陷阱后，这些卡片的状态
送墓确定状态中的卡无法返回手牌和卡组，并且连锁结束时送去墓地
此函数的作用是取消此状态使其留场，用于诱饵人偶和废铁稻草人等卡

●int,int Card.GetTributeRequirement(Card c)
返回通常召唤卡片 c 所需要的祭品的最小和最大数量

●Card Card.GetBattleTarget(Card c)
返回与卡片 c 进行战斗的卡，没有则返回nil

●Group,bool Card.GetAttackableTarget(Card c)
返回卡片 c 可攻击的卡片组以及能否直接攻击

●void Card.SetHint(Card c, int type, int value)
为卡片 c 设置类型为 type 的卡片提示信息
type 只能为以下值，对应的 value 类型为
CHINT_TURN              =1 --回合数
CHINT_CARD              =2 --卡片id
CHINT_RACE              =3 --种族
CHINT_ATTRIBUTE         =4 --属性
CHINT_NUMBER            =5 --数字
CHINT_DESC              =6 --描述

●void Card.ReverseInDeck(Card c)
设置卡片 c 在卡组中表面向上（POS_FACEUP_DEFENSE）

●void Card.SetUniqueOnField(Card c, int s, int o, function|int unique_code[, int unique_location=LOCATIOIN_ONFIELD])
设置卡片 c 以 unique_code 只能在场上[或怪兽区域或魔陷区域，由 unique_location 决定]只能存在1张。
s 不为0会检查自己场上的唯一性，o 不为0则检查对方场上的唯一性
如果 unique_code 是 function 类型，则需要返回一个 bool 类型的值，通常用于判定某系列在场的唯一性。函数原型如下(参考对象：地缚神 系列，罪 系列)
function filter(c)
end

●bool Card.CheckUniqueOnField(Card c,int check_player[, int check_location=LOCATION_ONFIELD, Card icard|nil])
检查卡片 c 在 check_player 场上[check_location 区域]的唯一性[, 忽略卡片 icard 的唯一性影响]
参考对象：晴天气 锈红<54895237>

●void Card.ResetNegateEffect(Card c[, int code1,...])
重置卡片 c 受到的卡号为 code1[, code2...]的卡片的效果的影响

●void Card.AssumeProperty(Card c,int assume_type, int assume_value)
把卡片 c 的 assume_type 的数值当作 assume_value 使用（基因组斗士）
assume_type为以下类型
ASSUME_CODE         =1 --卡号
ASSUME_TYPE         =2 --类型
ASSUME_LEVEL        =3 --等级
ASSUME_RANK         =4 --阶级
ASSUME_ATTRIBUTE    =5 --属性
ASSUME_RACE         =6 --种族
ASSUME_ATTACK       =7 --攻击力
ASSUME_DEFENSE      =8 --守备力

●void Card.SetSPSummonOnce(Card c, int spsummon_code)
设置卡片 c 一回合只能进行1次特殊召唤（灵兽，波动龙）
相同的 spsummon_code 共用1个次数

========== Effect ==========
●Effect Effect.CreateEffect(Card c)
新建一个空效果
并且效果的Owner为 c

●Effect Effect.GlobalEffect()
新建一个全局效果

●Effect Effect.Clone(Effect e)
新建一个效果 e 的副本

●void Effect.Reset(Effect e)
把效果 e 重置，重置之后不可以再使用此效果

●int Effect.GetFieldID(Effect e)
获取效果 e 的id

●void Effect.SetDescription(Effect e, int desc)
设置效果 e 的效果描述

●void Effect.SetCode(Effect e, int code)
设置效果 e 的Code属性

●void Effect.SetRange(Effect e, int range)
设置效果 e 的Range属性，即 e 的生效位置

●void Effect.SetTargetRange(Effect e, int s_range, int o_range)
设置效果 e 的TargetRange属性
	s_range 指影响的我方区域
	o_range 指影响的对方区域
	如果property属性中指定了EFFECT_FLAG_ABSOLUTE_RANGE标志，
		那么s_range指玩家1受到影响的区域，o_range指玩家2受到影响的区域
	如果这是一个召唤(覆盖)/限制召唤(覆盖)/特殊召唤手续
	(EFFECT_SUMMON_PROC/EFFECT_LIMIT_SUMMON_PROC/EFFECT_SPSUMMON_PROC等)的效果，
		并且property指定了EFFECT_FLAG_SPSUM_PARAM标志，
		那么 s_range 表示可选择的表示形式，
		o_range 表示特殊召唤到的哪个玩家的场地，0是己方，1是对方

●void Effect.SetAbsoluteRange(Effect e, int playerid, int s_range, int o_range)
设置效果 e 的TargetRange属性并设置 EFFECT_FLAG_ABSOLUTE_TARGET 标志
	如果 playerid != 0 ，则 s_range 和 o_range 反转

●void Effect.SetCountLimit(Effect e, int count=1[, int code=0])
设置效果 e 的一回合可以发动的次数 count（仅触发型效果有效），相同的 code (不等于0或1时)共用1个次数
code 包含以下数值具有特殊的性质
EFFECT_COUNT_CODE_OATH			=0x10000000 --发动次数限制(誓约次数, 发动被无效不计数)
EFFECT_COUNT_CODE_DUEL			=0x20000000 --决斗中使用次数
EFFECT_COUNT_CODE_SINGLE		=0x1		--同一张卡的多个效果公共使用次数

●void Effect.SetReset(Effect e, int reset_flag[, int reset_count=1])
设置效果 e 的reset参数

●void Effect.SetType(Effect e, int type)
为效果 e 设置Type属性
EFFECT_TYPE_SINGLE			=0x0001		--自己状态变化时触发
EFFECT_TYPE_FIELD			=0x0002		--场上所有卡状态变化时触发
EFFECT_TYPE_EQUIP			=0x0004		--装备效果
EFFECT_TYPE_ACTIONS			=0x0008		--触发型，以下類型會自動添加此屬性（对峙的G）
EFFECT_TYPE_ACTIVATE		=0x0010		--魔陷发动
EFFECT_TYPE_FLIP			=0x0020		--翻转效果
EFFECT_TYPE_IGNITION		=0x0040		--起动效果
EFFECT_TYPE_TRIGGER_O		=0x0080		--诱发选发效果
EFFECT_TYPE_QUICK_O			=0x0100		--诱发即时效果
EFFECT_TYPE_TRIGGER_F		=0x0200		--诱发必发效果
EFFECT_TYPE_QUICK_F			=0x0400		--诱发即时必发效果（熊猫龙等）
EFFECT_TYPE_CONTINUOUS		=0x0800		--由事件觸發的輔助用效果/永續效果
EFFECT_TYPE_XMATERIAL		=0x1000		--作为超量素材时超量怪兽获得的效果（十二兽）
EFFECT_TYPE_GRANT			=0x2000		--使其他卡片获得效果（天气模样）
EFFECT_TYPE_TARGET          =0x4000     --影响持续取的对象的效果（基本只用于魔陷）

●void Effect.SetProperty(Effect e, int prop1[, int prop2])
设置效果 e 的Property属性

●void Effect.SetLabel(Effect e, int label[, int label2, ...])
设置效果 e 的Label(可以设置多个)

●void Effect.SetLabelObject(Effect e, Card|Group|Effect labelobject)
设置效果 e 的LabelObject属性

●void Effect.SetCategory(Effect e, int cate)
设置效果 e 的Category属性

●void Effect.SetHintTiming(Effect e, int s_time[, int o_time=s_time])
设置效果 e 的提示时点，第二个和第三个参数分别表示 自己 和对方的回合

●void Effect.SetCondition(Effect e, function con_func)
设置效果 e 的Condition属性

●void Effect.SetCost(Effect e, function cost_func)
设置效果 e 的Cost属性

●void Effect.SetTarget(Effect e, function targ_func)
设置效果 e 的Target属性

●void Effect.SetValue(Effect e, function|int|bool val)
设置效果 e 的Value属性

●void Effect.SetOperation(Effect e, nil|function op_func)
设置效果 e 的Operation属性

●void Effect.SetOwnerPlayer(Effect e[, int player=0])
设置效果 e 的OwnerPlayer属性为 player

●int Effect.GetDescription(Effect e)
返回效果 e 的效果描述，没有则无返回值

●int Effect.GetCode(Effect e)
返回效果 e 的code属性，没有则无返回值

●int Effect.GetType(Effect e)
返回效果 e 的Type属性，没有则无返回值

●int,int Effect.GetProperty(Effect e)
返回效果 e 的Property属性，没有则无返回值

●int[,...] Effect.GetLabel(Effect e)
返回效果 e 的Label(全部返回)，没有则无返回值

●Card|Group|Effect Effect.GetLabelObject(Effect e)
返回效果 e 的LabelObject，没有则返回 nil

●int Effect.GetCategory(Effect e)
返回效果 e 的Category属性，没有则无返回值

●Card Effect.GetOwner(Effect e)
返回效果 e 的Owner属性，就是该效果的拥有卡

●Card Effect.GetHandler(Effect e)
返回效果 e 在哪一张卡上生效(通常是用Card.RegisterEffect注册该效果的卡)

●function Effect.GetCondition(Effect e)
返回效果 e 的condition属性

●function Effect.GetTarget(Effect e)
返回效果 e 的target属性

●function Effect.GetCost(Effect e)
返回效果 e 的cost属性

●function|int Effect.GetValue(Effect e)
返回效果 e 的value属性

●function Effect.GetOperation(Effect e)
返回效果 e 的operation属性

●int Effect.GetActiveType(Effect e)
返回效果 e 的效果类型（怪兽·魔法·陷阱等）
比如灵摆的结果是 灵摆+魔法

●bool Effect.IsActiveType(Effect e, int type)
检查效果 e 的效果类型（怪兽·魔法·陷阱等）是否有 type

●int Effect.GetOwnerPlayer(Effect e)
返回效果 e 的OwnerPlayer属性，一般是Owner的控制者

●int Effect.GetHandlerPlayer(Effect e)
返回效果 e 的当前控制者，一般是Handler的控制者

●bool Effect.IsHasProperty(Effect e, int prop1[, int prop2])
检查效果 e 是否含有标志 prop1[和 prop2]

●bool Effect.IsHasCategory(Effect e, int cate)
检查效果 e 是否含有效果分类 cate

●bool Effect.IsHasType(Effect e, int type)
检查效果 e 是否属于类型 type

●bool Effect.IsActivatable(Effect e, int player[, bool neglect_loc=false, bool neglect_target=false])
检查效果 e 能否由 player 发动
neglect_loc==true 为不检测发动位置， neglect_target==true 为不检测对象要求

●bool Effect.IsActivated(Effect e)
检查效果 e 能否是发动的效果，也就是以下类型
EFFECT_TYPE_ACTIVATE		=0x0010		--魔陷发动
EFFECT_TYPE_FLIP			=0x0020		--翻转效果
EFFECT_TYPE_IGNITION		=0x0040		--起动效果
EFFECT_TYPE_TRIGGER_O		=0x0080		--诱发选发效果
EFFECT_TYPE_QUICK_O			=0x0100		--诱发即时效果
EFFECT_TYPE_TRIGGER_F		=0x0200		--诱发必发效果
EFFECT_TYPE_QUICK_F			=0x0400		--诱发即时必发效果（熊猫龙等）

●int Effect.GetActivateLocation(Effect e)
返回效果 e 的发动区域

●int Effect.GetActivateSequence(Effect e)
返回效果 e 的发动区域序号

●bool Effect.CheckCountLimit(Effect e, int p)
检测玩家 p 是否还有可以发动的效果 e 的次数

●void Effect.UseCountLimit(Effect e, int p[, int count=1, bool oath_only=false])
手动减少玩家 p 对效果 e 的 count 个可用次数[ oath_only 为 该效果是否是 EFFECT_FLAG_OATH]

========== Group ==========
●Group Group.CreateGroup()
新建一个空的卡片组

●void Group.KeepAlive(Group g)
让卡片组 g 持续，把卡片组设置为效果的LabelObject需要设置

●void Group.DeleteGroup(Group g)
删除卡片组 g 

●Group Group.Clone(Group g)
新建卡片组 g 的副本

●Group Group.FromCards(...)
不定参数，把传入的所有卡组合成一个卡片组 g 并返回，所有参数只能是 Card 类型。没有参数时，相当于 Group.CreateGroup()

●void Group.Clear(Group g)
清空卡片组 g 里的内容

●void Group.AddCard(Group g, Card c)
往卡片组 g 中增加卡片c

●void Group.RemoveCard(Group g, Card c)
把卡片c从卡片组 g 中移除

●Card Group.GetFirst(Group g)
返回卡片组 g 中第一张卡，并重置当前指针到 g 中第一张卡
如果g中不存在卡则返回nil

●Card Group.GetNext(Group g)
使指针指向卡片组 g 下一张卡并返回这张卡，如果不存在则返回nil

●int Group.GetCount(Group g)
返回卡片组 g 中卡的数量

●int Group.__len(Group g)
和 Group.GetCount 一样

●void Group.ForEach(Group g, function f,...)
为卡片组 g 中的每一张卡调用一次 f ,第三个参数开始为额外参数

●Group Group.Filter(Group g, function f, Card|Group ex|nil, ...)
过滤函数，从卡片组 g 中筛选满足筛选条件 f 并且不等于 ex 的卡
从第4个参数开始为额外参数

●int Group.FilterCount(Group g, function f, Card|Group ex|nil, ...)
过滤函数，和 Group.Filter 基本相同，不同之处在于此函数只返回满足条件的卡的数量

●Group Group.FilterSelect(Group g, int player, function f, int minc, int maxc, Card|Group ex|nil, ...)
过滤函数，让玩家 player 从卡片组 g 中选择 minc-maxc 张满足筛选条件 f 并且不等于 ex 的卡
从第7个参数开始为额外参数

●Group Group.Select(Group g, int player, int minc, int maxc, Card|Group ex|nil)
让玩家 player 从卡片组 g 中选择 minc-maxc 张不等于 ex 的卡

●Card Group.SelectUnselect(Group cg, Group sg, int player[, bool btok=false, bool cancelable=false, int minc=1, int maxc=1])
让玩家 player 从卡片组 cg 中选择 1 张卡放入卡片组 sg ，并返回选的卡。  
btok 表示是否可以点击完成选择的按钮， cancelable 表示是否可以取消已选择的卡， 
minc 和 maxc 是客户端的文字缓冲提示，表示需要选择 minc-maxc 张卡，但是这个只是影响视觉效果，并不代表必须要选择那个数量

●Group Group.RandomSelect(Group g, int player, int count)
让玩家 player 从卡片组 g 中随机选择 count 张卡
因为是随机选择，所以参数 player 基本无用，由系统随机选取

●bool Group.IsExists(Group g, function f, int count, Card|Group ex|nil, ...)
过滤函数，检查卡片组 g 中是否存在至少 count 张满足筛选条件 f 并且不等于 ex 的卡
从第5个参数开始为额外参数

●bool Group.CheckWithSumEqual(Group g, function f, int sum, int minc=0, int maxc, ...)
子集求和判定函数，f 为返回一个interger值的函数
检查卡片组 g 中是否存在一个数量为 minc-maxc 的子集满足以f对子集的每一个元素求值的和等于 sum，从第6个参数开始为额外参数
	比如：g:CheckWithSumEqual(Card.GetSynchroLevel,7,2,99)
	检查 g 中是否存在一个子集元素数量在 2-99 之间的子集，并且满足子集的同调用等级之和等于7

●Group Group.SelectWithSumEqual(Group g, int player, function f, int sum, int minc, int maxc, ...)
让玩家 player 从卡片组 g 中选取一个数量为 minc-maxc 的子集使子集的特定函数 f 的和等于 sum，从第7个参数开始为额外参数

●bool Group.CheckWithSumGreater(Group g, function f, int sum, ...)
子集求和判定函数之二，f 为返回一个interger值的函数
检查卡片组 g 中是否存在一个子集满足以f对子集的每一个元素求值的和刚好大于或者等于sum，从第4个参数开始为额外参数
比如：g:CheckWithSumGreater(Card.GetRitualLevel,8)
	检查 g 中是否存在一个子集满足子集的仪式用等级之和大于等于8
	注：判定必须是“刚好”大于或者等于
	以等级为例，要使等级合计大于等于8，可以选择LV1+LV7而不可以选择LV1+LV4+LV4(在这些选择都满足的情况下)

●Group Group.SelectWithSumGreater(Group g, int player, function f, int sum, ...)
让玩家 player 从卡片组 g 中选取一个子集使子集的特定函数 f 的和刚好大于等于 sum，从第5个参数开始为额外参数

●Group,int Group.GetMinGroup(Group g, function f, ...)
f 为返回一个interger值的函数，从卡片组 g 中筛选出具有最小的 f 的值的卡(可能会有多个满足条件的)
第2个返回值为这个最小值，从第3个参数开始为额外参数
要使用第2个返回值注意检查g非空

●Group,int Group.GetMaxGroup(Group g, function f, ...)
f 为返回一个interger值的函数，从卡片组 g 中筛选出具有最大的 f 的值的卡(可能会有多个满足条件的)
第2个返回值为这个最大值，从第3个参数开始为额外参数
要使用第2个返回值注意检查g非空

●int Group.GetSum(Group g, function f, ...)
计算卡片组 g 中所有卡的取值的总和，f 为为每张卡的取值函数(返回值类型是interger)，从第3个参数开始为额外参数
参考对象：狱火机 系列
等价于：
function GetSum(g,f,...)
	local ct=0
	local val={...}
	for tc in aux.Next(g)
		if f(tc,table.unpack(val)) then ct=ct+1 end
	end
	return ct
end

●int Group.GetClassCount(Group g, function f, ...)
计算卡片组 g 中所有卡的种类数量，f 为分类的依据，返回相同的值视为同一种类，从第3个参数开始为额外参数
比如 g:GetClassCount(Card.GetCode) 就是计算g中卡名不同的卡的数量

●void Group.Remove(Group g, function f, Card ex|nil, ...)
从卡片组 g 中移除满足筛选条件 f 并且不等于 ex 的所有卡，第4个参数开始是额外参数

●void Group.Merge(Group g1, Group g2)
把卡片组 g2 中的所有卡合并到卡片组 g1，若 g1 中原本就有属于 g2 的卡，那些卡将不会重复
注：g2 本身不会发生变化

●void Group.Sub(Group g1, Group g2)
从卡片组 g1 中移除属于卡片组 g2 中的卡
注：g2 本身不会发生变化

●bool Group.Equal(Group g1, Group g2)
判断卡片组 g1 和卡片组 g2 是否相同

●bool Group.IsContains(Group g, Card c)
检查卡片组 g 中是否存在卡片 c

●Card Group.SearchCard(Group g, function f, ...)
过滤函数，返回卡片组 g 中满足筛选条件 f 的第一张卡，若没有则返回nil，从第3个参数开始为额外参数

●int Group.GetBinClassCount(Group g, function f, ...)
和 Group.GetClassCount 类似，但是算法不同(使用位运算)

●Group Group.__add(Group|Card target1, Group|Card target2)
新建一个卡片组，将 target1 和 target2 中的 全部卡添加到这个卡片组，并返回这个卡片组，若有相同的卡只会添加1次， target1,target2 本身不会有任何变化

●Group Group.__bor(Group|Card target1, Group|Card target2)
代码和 Group.__add 完全一样

●Group Group.__sub(Group|Card target1, Group|Card target2)
新建一个卡片组，将 target1 中的 全部卡添加到这个卡片组，然后再从这个卡片组把 target2 的卡全部删除，最后返回这个卡片组，target1,target2 本身不会有任何变化

●Group Group.__band(Group|Card target1, Group|Card target2)
新建一个卡片组，将 target1 和 target2 中相同的卡（就是那张卡同时存在于 target1 和 target2 ）全部添加到 这个卡片组里，最后返回这个卡片组，target1,target2 本身不会有任何变化

●Group Group.__bxor(Group|Card target1, Group|Card target2)
新建一个卡片组，将 target1 和 target2 中不同的卡（就是只存在于 target1 或者 target2 里的卡）全部添加到 这个卡片组里，最后返回这个卡片组，target1,target2 本身不会有任何变化

========== Duel ==========
●void Duel.EnableGlobalFlag(int global_flag)
设置全局标记 global_flag

●int Duel.GetLP(int player)
返回玩家 player 的当前LP

●void Duel.SetLP(int player, int lp)
设置玩家 player 的当前LP为 lp

●int Duel.GetTurnPlayer()
返回当前的回合玩家

●int Duel.GetTurnCount([int player])
返回[玩家 player 所经过的]当前的回合数

●int Duel.GetDrawCount(int player)
返回玩家 player 每回合的规则抽卡数量

●void Duel.RegisterEffect(Effect e, int player)
把效果 e 作为玩家 player 的效果注册给全局环境

●Effect Duel.RegisterFlagEffect(int player, int code, int reset_flag, int property, int reset_count=1[, int label=0])
为玩家 player 注册全局环境下的标识效果，并返回这个效果
此效果总是影响玩家的(EFFECT_FLAG_PLAYER_TARGET)并且不会被无效化
其余部分与 Card.RegisterFlagEffect 相同

●int Duel.GetFlagEffect(int player, int code)
返回玩家 player 的 code 标识效果的数量

●void Duel.ResetFlagEffect(int player, int code)
手动reset玩家 player 的 code 标识效果

●bool Duel.SetFlagEffectLabel(int player, int code, int label)
返回玩家 player 是否存在种类为 code 的标识效果，并设置其Label属性为 label (原先的Label会被清除)

●int[,...] Duel.GetFlagEffectLabel(int player, int code)
返回玩家 player 的种类为 code 的标识效果的全部Label，没有此效果标识则返回nil

●int Duel.Destroy(Card|Group targets, int reason[ ,int dest = LOCATION_GRAVE])
以 reason 原因破坏 targets 去 dest，返回值是实际被破坏的数量
如果 reason 包含 REASON_RULE，则破坏事件将不会检查卡片是否免疫效果，不会触发代破效果并且无视“不能破坏”

●int Duel.Remove(Card|Group targets, int pos, int reason)
以 reason 原因，pos 表示形式除外 targets，返回值是实际被操作的数量
如果 reason 包含 REASON_TEMPORARY，那么视为是暂时除外，可以通过 Duel.ReturnToField 返回到场上

●int Duel.SendtoGrave(Card|Group targets, int reason)
以 reason 原因把 targets 送去墓地，返回值是实际被操作的数量

●int Duel.SendtoHand(Card|Group targets, int player|nil, int reason)
以 reason 原因把 targets 送去玩家 player 的手牌，返回值是实际被操作的数量
如果 player==nil 则返回卡的持有者的手牌

●int Duel.SendtoDeck(Card|Group targets, int player|nil, int seq, int reason)
以 reason 原因把 targets 送去玩家 player 的卡组，返回值是实际被操作的数量
如果 player==nil 则返回卡的持有者的卡组
如果 seq==0，则是返回卡组最顶端；seq==1则是返回卡组最底端；
其余情况则是返回最顶端并且标记需要洗卡组

●int Duel.SendtoExtraP(Card|Group targets, int player|nil, int reason)
以 reason 原因把灵摆卡targets表侧表示送去玩家 player 的额外卡组，返回值是实际被操作的数量
如果 player==nil 则返回卡的持有者的额外卡组

●Group Duel.GetOperatedGroup()
此函数返回之前一次卡片操作实际操作的卡片组。包括
Duel.Destroy, Duel.Remove, Duel.SendtoGrave, 
Duel.SendtoHand, Duel.SendtoDeck, Duel.SendtoExtraP, Duel.Release, 
Duel.ChangePosition, Duel.SpecialSummon, Duel.DiscardDeck

●void Duel.Summon(int player, Card c, bool ignore_count, Effect e|nil[, int minc=0, int zone=0x1f])
让玩家 player 以效果 e 对卡片 c[在区域 zone]进行通常召唤(非set)，至少使用 minc 个祭品
如果 e=nil,那么就按照一般的通常召唤规则进行通常召唤
如果 ignore_count=true，则忽略每回合的通常召唤次数限制

●void Duel.SpecialSummonRule(int player, Card c[, int sumtype=0])
让玩家 player 对卡片 c[用 sumtype 方式]进行特殊召唤手续（？）

●void Duel.SynchroSummon(int player, Card c, Card tuner|nil[, Group mg|nil, int minc=0, int maxc=0])
让玩家 player 以 tuner 作为调整,场上[或 mg 中][minc-maxc 张]的卡为素材，对卡片 c 进行同调召唤手续

●void Duel.XyzSummon(int player, Card c, Group mg|nil[, int minc=0, int maxc=0])
让玩家 player 用场上的卡[或 mg 中][选 minc-maxc 个素材]对卡片 c 进行超量召唤手续
mg 非空且 minc==0 则直接把 mg 全部作为超量素材

●void Duel.LinkSummon(int player, Card c, Group mg|nil[, Card lc, int minc=0, int maxc=0])
让玩家 player 用场上[或mg][包含卡片 lc 在内][minc-maxc 张]的卡对卡片 c 进行连接召唤手续

●void Duel.MSet(int player, Card c, bool ignore_count, Effect e|nil[,int minc=0, int zone=0x1f])
让玩家 player 以效果 e 对卡片 c[在区域 zone]进行通常召唤的Set，至少使用 minc 个祭品
如果 e==nil,那么就按照一般的通常召唤规则进行通常召唤
如果 ignore_count==true，则忽略每回合的通常召唤次数限制

●void|int Duel.SSet(int player, Card|Group targets[, int target_player=player, bool confirm=true])
让玩家 player 把 targets 盖放到 target_player 的魔法陷阱区， confirm 表示是否需要确认，返回成功操作的数量
若 targets 为Group类型并且为空，则无返回值

●bool|Card Duel.CreateToken(int player, int code)
根据 code 新建一个衍生物并返回这个卡，该衍生物的拥有者为 player
如果 player 不是 0或者1，则返回false

●int Duel.SpecialSummon(Card|Group targets, int sumtype, int sumplayer, int target_player, bool nocheck, bool nolimit, int pos[, int zone=0xff])
让玩家 sumplayer 以 sumtype 方式，pos 表示形式把 targets 特殊召唤到 target_player 场上[的区域 zone]
如果 nocheck==true 则无视卡的召唤条件，如果 nolimit==true 则无视卡的苏生限制
返回值是特殊召唤成功的卡的数量

●bool Duel.SpecialSummonStep(Card c, int sumtype, int sumplayer, int target_player, bool nocheck, bool nolimit, int pos[, int zone=0xff])
此函数是 Duel.SpecialSummon 的分解过程，只特殊召唤一张卡c ，其他参数用法和 Duel.SpecialSummon 一样
此函数用于一个效果同时特殊召唤多张参数不同的卡
此函数必须和 Duel.SpecialSummonComplete()一起使用
返回值表示是否特殊召唤成功

●int Duel.SpecialSummonComplete()
此函数在确定复数个 Duel.SpecialSummonStep 调用完毕之后调用，用于触发事件

●bool Duel.IsCanAddCounter(int player[, int countertype, int count, Card c])
检查玩家 player 能否[向卡片 c]添加[count 个 countertype 类型的]指示物，如果 player 不是 0或者1，则返回false
额外参数如果要用，必须全写

●bool Duel.RemoveCounter(int player, int s, int o, int countertype, int count, int reason)
让玩家 player 以 reason 为原因移除场上存在的 countertype 类型的 count 个指示物，返回值表示是否成功
s 表示对 player 来说的己方的可移除指示物的位置，o 表示对 player 来说的对方的可移除指示物的位置

●bool Duel.IsCanRemoveCounter(int player, int s, int o, int countertype, int count, int reason)
检查玩家 player 以 reason 为原因是否能移除场上的 countertype 类型的 count 个指示物
s 表示对 player 来说的己方的可移除指示物的位置，o 表示对 player 来说的对方的可移除指示物的位置

●int Duel.GetCounter(int player, int s, int o, int countertype)
返回场上存在的 countertype 类型的指示物的数量
s 表示对 player 来说的己方的位置，o 表示对 player 来说的对方的位置

●int Duel.ChangePosition(Card|Group targets, int au[, int ad=au, int du=au, int dd=au, bool noflip=false, bool setavailable=false])
根据对应位置的参数改变targets里 对应形式 的表示形式。返回实际操作的数量。
若只有2个参数，则不管什么表示形式，都变成 第二个参数 代表的形式
表侧攻击表示 = au
里侧攻击表示 = ad
表侧守备表示 = du
里侧守备表示 = dd
如果 noflip==true 则不触发反转效果（但会触发反转时的诱发效果）
如果 setavailable==true 则对象之后变成里侧也发动反转效果
比如: Duel.ChangePosition(g,POS_FACEUP_DEFENSE,POS_FACEUP_DEFENSE,POS_FACEUP_ATTACK,POS_FACEUP_DEFENSE)
就表示 把卡片组 g  中 原本(表侧攻击表示的卡 和 里侧攻击表示的卡 和 里侧守备表示的卡) 变成 表侧守备表示，
	原本 表侧守备表示的卡 变成 表侧攻击表示

●int Duel.Release(Card|Group targets, int reason)
以 reason 原因解放 targets ，返回值是实际解放的数量
如果reason含有REASON_COST，则不会检查卡片是否不受效果影响

●bool Duel.MoveToField(Card c, int move_player, int target_player, int dest, int pos, bool enable[, int zone=0xff])
让玩家 move_player 把卡片 c 移动到 target_player 的场上的 dest 区域，返回值表示是否成功
dest 只能是 LOCATION_MZONE, LOCATION_SZONE, LOCATION_FZONE, LOCATION_PZONE , pos 表示可选表示形式， enable 表示是否立刻适用 c 的效果， zone 表示必须要放到的格子
场地魔法必须写 LOCATION_FZONE 
如果要灵摆怪兽作为灵摆魔法移到灵摆区，必须写 LOCATION_PZONE

●bool Duel.ReturnToField(Card c[, int pos, int zone=0xff])
把卡片 c[以表示形式 pos]返回到场上[的区域 zone]，pos 默认值是离场前的表示形式，返回值表示是否成功
c 必须是以 REASON_TEMPORARY 原因离场，并且离场后没有离开过那个位置

●void Duel.MoveSequence(Card c, int seq)
移动卡片 c 的序号，通常用于在场上换格子或者在卡组中移动到最上方或者最下方
比如对卡组中的 c 使用这个 Duel.MoveSequence(c,1), 就是把卡片 c 放到卡组最下面

●void Duel.SwapSequence(Card c1, Card c2)
交换卡片 c1 和卡片 c2 的位置

●void Duel.Activate(Effect e)
发动效果 e （？）

●void Duel.SetChainLimit(function f)
设定连锁条件，f 的函数原型为 bool f(e,ep,tp)
e 表示要限制连锁的效果，ep 表示要限制连锁的玩家，tp 表示发动该效果的玩家
在 cost 或者 target 处理中调用此函数可以限制可以连锁的效果的种类（如超融合）
如果 f 返回false表示不能连锁，一旦设置连锁条件后发生了新的连锁那么连锁条件将会解除

●void Duel.SetChainLimitTillChainEnd(function f)
功能同 Duel.SetChainLimit，但是此函数设定的连锁条件直到连锁结束才会解除

●Effect Duel.GetChainMaterial(int player)
返回玩家 player 受到的连锁素材的效果，此函数仅用于融合类卡的效果

●void Duel.ConfirmDecktop(int player, int count)
确认玩家 player 卡组最上方 count 张卡

●void Duel.ConfirmExtratop(int player, int count)
确认玩家 player 额外卡组里侧的卡 最上方 count 张卡

●void Duel.ConfirmCards(int player, Card|Group targets)
给玩家 player 确认 targets 

●void Duel.SortDecktop(int sort_player, int target_player, int count)
让玩家 sort_player 对玩家 target_player 的卡组最上方 count 张卡进行排序，最先选的卡在最上面，然后下面是第二张选择的卡，以此类推
最多只能排序16张卡

●bool[,Group,int,int,Effect,int,int] Duel.CheckEvent(int event[, bool get_info])
检查当前是否是 event 时点
若 get_info==true 并且是正确的时点，则还返回触发时点的信息 eg,ep,ev,re,r,rp

●void Duel.RaiseEvent(Group|Card eg, int code, Effect re, int r, int rp, int ep, int ev)
以 eg,ep,ev,re,r,rp 触发一个时点 code

●void Duel.RaiseSingleEvent(Card eg, int code, Effect re, int r, int rp, int ep, int ev)
以 eg,ep,ev,re,r,rp 触发一个单体时点 code

●bool Duel.CheckTiming(int timing)
检查当前是否是 timing 提示时点
TIMING_DRAW_PHASE			=0x1			--抽卡阶段时点
TIMING_STANDBY_PHASE		=0x2        	--准备阶段时点
TIMING_MAIN_END				=0x4        	--主要阶段结束时点
TIMING_BATTLE_START			=0x8        	--战斗阶段开始时点
TIMING_BATTLE_END			=0x10       	--战斗阶段结束时点
TIMING_END_PHASE			=0x20       	--结束阶段时点
TIMING_SUMMON				=0x40       	--召唤时点
TIMING_SPSUMMON				=0x80       	--特殊召唤时点
TIMING_FLIPSUMMON			=0x100      	--翻转召唤时点
TIMING_MSET					=0x200			--放置怪兽时点
TIMING_SSET					=0x400      	--放置魔陷时点
TIMING_POS_CHANGE			=0x800      	--表示形式变更时点
TIMING_ATTACK				=0x1000     	--攻击宣言时点
TIMING_DAMAGE_STEP			=0x2000     	--伤害步骤时点
TIMING_DAMAGE_CAL			=0x4000     	--伤害计算时点
TIMING_CHAIN_END			=0x8000     	--连锁结束时点
TIMING_DRAW					=0x10000    	--抽卡时点（不是抽卡阶段
TIMING_DAMAGE				=0x20000    	--造成伤害时点
TIMING_RECOVER				=0x40000		--回复时点
TIMING_DESTROY				=0x80000    	--破坏时点
TIMING_REMOVE				=0x100000   	--除外时点
TIMING_TOHAND				=0x200000   	--加入手牌时点（检索、回收等）
TIMING_TODECK				=0x400000   	--回卡组时点
TIMING_TOGRAVE				=0x800000   	--进墓地时点
TIMING_BATTLE_PHASE			=0x1000000  	--战斗阶段时点
TIMING_EQUIP				=0x2000000  	--装备时点
TIMING_BATTLE_STEP_END		=0x4000000  	--戰鬥步驟結束時

●int,int Duel.GetEnvironment()
返回两个值，表示当前场地代号，以及当前场地效果的来源玩家
场地代号指当前生效的场地卡的代号，或者海神的巫女等卡把场地变化效果的值
来源玩家指当前生效的场地卡的控制者，或者海神的巫女等卡的控制者

●bool Duel.IsEnvironment(int code[, int player=PLAYER_ALL, int loc = LOCATION_FZONE + LOCATION_ONFIELD])
检查场地代号是否是code [，来源玩家是否是 player][，生效区域是否在 loc 内]
场地代号指当前生效的场地卡的代号，或者海神的巫女把场地变化效果的值
来源玩家指当前生效的场地卡的控制者，或者海神的巫女等卡的控制者

●void Duel.Win(int player, int win_reason)
当前效果处理完令 playe r以 win_reason 决斗胜利

●int Duel.Draw(int player, int count, int reason)
让玩家 player 以原因 reason 抽 count 张卡，返回实际抽的卡的数量
如果 reason 含有 REASON_RULE 则此次抽卡不受“不能抽卡”的效果的影响

●int Duel.Damage(int player, int value, int reason[, bool is_step=false])
以 reason 原因给与玩家 player 造成 value 的伤害，返回实际收到的伤害值
如果受到伤害变成回复等效果的影响时，返回值为0.
is_step==true 则是伤害/恢复LP过程的分解，需要调用 Duel.RDComplete()触发时点

●int Duel.Recover(int player, int value, int reason[, bool is_step=false])
以 reason 原因使玩家 player 回复 value 的LP，返回实际的回复值
如果受到回复变成伤害等效果的影响时，返回值为0.
is_step==true 则是伤害/恢复LP过程的分解，需要调用 Duel.RDComplete()触发时点

●void Duel.RDComplete()
在调用Duel.Damage/Duel.Recover时，若is_step参数为true，则需调用此函数触发时点

●bool Duel.Equip(int player, Card c1, Card c2[, bool up=true, bool is_step=false])
让玩家 player 把卡片 c1 作为装备卡装备给卡片 c2，返回值表示是否成功
up==false 则保持装备卡之前的表示形式
is_step==true 则是装备过程的分解，需要配合 Duel.EquipComplete()使用

●void Duel.EquipComplete()
在调用Duel.Equip时，若is_step参数为true，则需调用此函数触发时点

●int Duel.GetControl(Card|Group targets, int player[, int reset_phase=0, int reset_count=0, int zone=0xff])
让玩家 player [直到发生 reset_count 次 reset_phase 之前][在区域 zone]得到 targets 的控制权，返回值表示处理的数量
reset_phase ,reset_count 若要使用，必须都用
PHASE_DRAW			=0x01	--抽卡阶段
PHASE_STANDBY		=0x02	--准备阶段
PHASE_MAIN1			=0x04	--主要阶段1
PHASE_BATTLE_START	=0x08	--战斗阶段开始
PHASE_BATTLE_STEP	=0x10	--战斗步驟
PHASE_DAMAGE		=0x20	--伤害步驟
PHASE_DAMAGE_CAL	=0x40	--伤害计算时
PHASE_BATTLE		=0x80	--战斗阶段結束
PHASE_MAIN2			=0x100	--主要阶段2
PHASE_END			=0x200	--结束阶段

●bool Duel.SwapControl(Card|Group targets1, Card|Group targets2[, int reset_phase=0, int reset_count=0])
交换 targets1 与 targets2 的控制权，返回值表示是否成功
targets1 与 targets2 的类型必须相同，他们的数量如果不同则会返回 false
第三个第四个参数同 Duel.GetControl

●bool Duel.CheckLPCost(int player, int cost)
检查玩家 player 是否能支付cost点lp

●void Duel.PayLPCost(int player, int cost)
让玩家 player 支付 cost 点LP

●int Duel.DiscardDeck(int player, int count, int reason)
以原因 reason 把玩家 player 的卡组最上端 count 张卡送去墓地，返回实际转移的数量

●int Duel.DiscardHand(int player, function f|nil, int minc, int maxc, int reason, Card|Group ex|nil, ...)
过滤函数让玩家 player 选择并以 reason 原因丢弃满足筛选条件 f 并且不等于 ex 的 minc-maxc 张手卡
第7个参数开始为额外参数

●void Duel.DisableShuffleCheck([bool disable=true])
使下一个操作不检查是否需要洗切卡组或手卡
注：如果不调用此函数，
除了调用 Duel.DiscardDeck 和 Duel.Draw 之外从卡组中取出卡，或者把卡加入手卡，
或者把卡加入卡组（非最上端或最底端）时，系统会自动在效果处理结束时洗切卡组或手卡。
如果不希望如此，比如从卡组顶端除外一张卡等操作，那么需要调用此函数。
此函数仅保证紧接着的一次操作不会进行洗卡检测

●void Duel.DisableSelfDestroyCheck([bool disable=true])
让自毁检测无效(?)

●void Duel.ShuffleDeck(int player)
手动洗切玩家 player 的卡组
注：会重置洗卡检测的状态

●void Duel.ShuffleExtra(int player)
手动洗切玩家 player 的额外卡组

●void Duel.ShuffleHand(int player)
手动洗切玩家 player 的手卡
注：会重置洗卡检测的状态

●void Duel.ShuffleSetCard(Group g)
洗切覆盖的卡片组 g （实例：魔术礼帽），若g中有表侧表示的卡，则此函数无效
此函数现在可以洗切魔陷区的覆盖卡

●void Duel.ChangeAttacker(Card c[, bool ignore_count=false])
将攻击怪兽变为卡片 c
若 ignore_count==true 则原来的攻击怪兽不视为攻击过

●bool Duel.ChangeAttackTarget(Card c|nil)
将攻击对象变为卡片 c，c==nil 表示直接攻击，返回值表示是否成功转移攻击对象

●void Duel.CalculateDamage(Card c1, Card c2[, bool new_attack=false])
令卡片 c1 与卡片 c2 进行战斗伤害计算（c1 攻击 c2）
若 new_attack==true 则视为 攻击的卡进行过攻击宣言（？）

●int Duel.GetBattleDamage(int player)
返回玩家 player 在本次战斗中受到的伤害

●void Duel.ChangeBattleDamage(int player, int value[, bool check=true])
把玩家 player 在本次战斗中受到的伤害变成value，若 check==false 则原本战斗伤害就算为0也改变伤害

●void Duel.ChangeTargetCard(int chainc, Group g)
把连锁 chainc 的对象换成卡片组 g 
chainc==0 表示当前连锁

●void Duel.ChangeTargetPlayer(int chainc, in player)
把连锁 chainc 的对象玩家换成玩家 player 
chainc==0 表示当前连锁

●void Duel.ChangeTargetParam(int chainc, int param)
把连锁 chainc 的参数换成 param 
chainc==0 表示当前连锁

●void Duel.BreakEffect()
中断当前效果，使之后的效果处理视为不同时处理，此函数会造成错时点

●void Duel.ChangeChainOperation(int chainc, function f)
把连锁 chainc 的效果的处理函数换成 f，用于实现“把效果变成”等的效果
chainc==0 表示当前连锁
f(e,tp,eg,ep,ev,re,r,rp)

●bool Duel.NegateActivation(int chainc)
使连锁 chainc 的发动无效，返回值表示是否成功
chainc==0 表示当前连锁

●bool Duel.NegateEffect(int chainc)
使连锁 chainc 的效果无效，返回值表示是否成功
chainc==0 表示当前连锁

●void Duel.NegateRelatedChain(Card c, int reset)
使和卡片  c有关的连锁都无效化，发生 reset 事件则重置,reset 默认包含 RESET_CHAIN

●void Duel.NegateSummon(Card|Group targets)
使正在召唤·反转召唤·特殊召唤的 targets 的召唤无效

●void Duel.IncreaseSummonedCount([Card c])
手动增加1次玩家[对于卡片 c]的已经通常召唤过的次数

●bool Duel.CheckSummonedCount([Card c])
检查回合玩家本回合是否还能通常召唤[卡片 c]

●int,int Duel.GetLocationCount(int player, int location[, int use_player, int reason = LOCATION_REASON_TOFIELD, int zone=0xff])
返回玩家 player 的场上区域 location 内的可用的[区域 zone 里的]空格数(一般不计算ex格子 和 场地区)
location 只能是 LOCATION_MZONE 或者 LOCATION_SZONE
reason 为 LOCATION_REASON_TOFIELD 或 LOCATION_REASON_CONTROL
##第三个第四个额外参数与凯撒斗技场等限制格子的效果有关
第2个返回值表示 player 场上的可用的格子以外的格子的代码

●int,int Duel.GetMZoneCount(int player[, Group|Card targets|nil, int use_player, int reason = LOCATION_REASON_TOFIELD, int zone=0xff])
返回玩家 player 场上[targets 离开后]可用的[区域 zone 里的]主要怪兽区数量
##第三个第四个额外参数与凯撒斗技场等限制格子的效果有关
第2个返回值表示 player 场上的可用的格子以外的格子的代码

●int,int Duel.GetLocationCountFromEx(int player[, int reason_player=player, Group|Card targets|nil, (Card sc)|(int type), int zone=0xff])
返回玩家 player 场上[假如因玩家 reason_player 的原因让 targets 离场后，把卡片 sc 在 zone 区域特殊召唤]可用的 能让额外卡组的怪兽 出场的空格数
第4个参数可以传入 int 类型(参考对象： 笑容宇宙<35259350>)
第2个返回值表示 player 场上的可用的格子以外的格子的代码

●int Duel.GetUsableMZoneCount(int player[, int use_player])
返回玩家 player 场上[对于 use_player 来说]可用的怪兽区数量（计算 ex 和 main）

●Group Duel.GetLinkedGroup(int player, int s_range, int o_range)
返回以玩家 player 来看的 s_range 和 o_range 区域的处于连接标记指向区域的卡片组[s_range 和 o_range 只要不为0，都会变成 LOCATION_MZONE]
s_range 我方区域，o_range 对方区域
比如: tp 玩家左数第二个格子有个防火龙，那个格子上面的ex 格子有个对方的怪兽，防火龙左边和右边的格子都有怪兽，那么
 Duel.GetLinkedGroup(tp,0,9999) 就是返回那只怪兽(返回类型是卡片组)，Duel.GetLinkedGroup(tp,1234,0) 就是返回防火龙左右2边的那2只怪兽。

●int Duel.GetLinkedGroupCount(int player, int s_range, int o_range)
返回以玩家 player 来看的 s_range 和 o_range 区域的处于连接标记指向区域的卡片的数量[s_range 和 o_range 只要不为0，都会变成 LOCATION_MZONE]
s_range 我方区域，o_range 对方区域
比如: tp 玩家左数第二个格子有个防火龙，那个格子上面的ex 格子有个对方的怪兽，防火龙左边和右边的格子都有怪兽，那么
 Duel.GetLinkedGroup(tp,0,9999) 的返回值就是 1 ，Duel.GetLinkedGroup(tp,1234,0) 的返回值就是 2

●int Duel.GetLinkedZone(int player)
返回以玩家 player 来看的所有连接区域

●Card Duel.GetFieldCard(int player, int location, int seq)
返回玩家 player 的场上位于区域 location 序号为 seq 的卡，常用于获得场地区域·灵摆区域的卡
注：召唤·反转召唤·特殊召唤 之际 或者 发动被无效 的卡无法获取

●bool Duel.CheckLocation(int player, int location, int seq)
检查玩家 player 的场上位于区域 location 序号为 seq 的空格是否可用

●int Duel.GetCurrentChain()
返回当前正在处理的连锁序号

●... Duel.GetChainInfo(int chainc, ...)
返回连锁 chainc 的信息，如果 chainc==0，则返回当前正在处理的连锁的信息
此函数根据传入的参数个数按顺序返回相应数量的返回值。参数可以是:
CHAININFO_CHAIN_COUNT			=0x01	--连锁数
CHAININFO_TRIGGERING_EFFECT		=0x02	--连锁的效果
CHAININFO_TRIGGERING_PLAYER		=0x04	--连锁的玩家
CHAININFO_TRIGGERING_CONTROLER	=0x08	--连锁的卡的控制者
CHAININFO_TRIGGERING_LOCATION	=0x10	--连锁的位置
CHAININFO_TRIGGERING_SEQUENCE	=0x20	--连锁的位置的编号（指怪兽和魔陷区的格子）
CHAININFO_TARGET_CARDS			=0x40	--连锁的效果的对象（以下3个需要在target函数里设置）
CHAININFO_TARGET_PLAYER			=0x80	--连锁的效果的对象（玩家）
CHAININFO_TARGET_PARAM			=0x100	--连锁的效果的参数值
CHAININFO_DISABLE_REASON		=0x200	--无效的原因
CHAININFO_DISABLE_PLAYER		=0x400	--无效的玩家
CHAININFO_CHAIN_ID				=0x800	--连锁ID
CHAININFO_TYPE					=0x1000	--连锁类型
CHAININFO_EXTTYPE				=0x2000	--连锁额外类型
CHAININFO_TRIGGERING_POSITION	=0x4000	--连锁发生时的表示形式
CHAININFO_TRIGGERING_CODE		=0x8000	--连锁发生时的密码
CHAININFO_TRIGGERING_CODE2		=0x10000	--连锁发生时的其他密码
CHAININFO_TRIGGERING_LEVEL		=0x40000	--连锁发生时的等级
CHAININFO_TRIGGERING_RANK		=0x80000	--连锁发生时的阶级
CHAININFO_TRIGGERING_ATTRIBUTE	=0x100000	--连锁发生时的属性
CHAININFO_TRIGGERING_RACE		=0x200000	--连锁发生时的种族
CHAININFO_TRIGGERING_ATTACK		=0x400000	--连锁发生时的攻击力
CHAININFO_TRIGGERING_DEFENSE	=0x800000	--连锁发生时的守备力
举例：
Duel.GetChainInfo(0,CHAININFO_TRIGGERING_LOCATION,CHAININFO_TARGET_CARDS)
将会返回当前连锁发生的位置和对象卡

●Group,int,int,Effect,int,int Duel.GetChainEvent(int chainc)
返回连锁 chainc 的相关参数，如果 chainc==0，则返回当前正在处理的连锁的相关参数
返回6个参数，eg,ep,ev,re,r,rp

●Card,... Duel.GetFirstTarget()
返回当前连锁的第一次的所有的对象卡，一般只有一个对象时使用
##多个对象也能使用，剩下的对象依次按顺序返回，但是很容易记错对象的顺序，所以不建议对多个对象使用

●int Duel.GetCurrentPhase()
返回当前的阶段

●void Duel.SkipPhase(int player, int phase, int reset_flag, int reset_count[, int value])
跳过玩家 player 的 phase 阶段，并在特定的阶段后 reset，reset参数和效果相同
value 只对 phase==PHASE_BATTLE 才有用，value==1 跳过战斗阶段的结束步骤，用于“变成回合结束阶段”等（招财猫王，闪光弹）

●bool Duel.IsDamageCalculated()
用于在伤害阶段检查是否已经计算了战斗伤害

●Card Duel.GetAttacker()
返回此次战斗攻击的卡

●Card|nil Duel.GetAttackTarget()
返回此次战斗被攻击的卡，如果返回nil表示是直接攻击

●Card,Card Duel.GetBattleMonster(int player)
返回本次进行战斗的怪兽。以玩家 player 来看，第一个是自己的怪兽，第二个是对方的怪兽，没有进行战斗的怪兽的话，则为nil(2个返回值都可能会有 nil 的值)

●bool Duel.NegateAttack()
无效此次攻击，返回值表示是否成功
此次攻击已经被其他效果无效或导致攻击的卡不能攻击则返回false

●void Duel.ChainAttack([Card c])
使攻击卡[或卡片 c]可以再进行1次攻击（比如 大开辟，破灭的女王）

●void Duel.Readjust()
刷新场上的卡的信息
非特定情况或者不清楚原理请勿使用此函数以免形成死循环

●void Duel.AdjustInstantly([Card c])
手动刷新场上[受到卡片 c 影响]的卡的无效状态

●Group Duel.GetFieldGroup(int player, int s, int o)
返回以 player 来看的指定位置的卡，s 代表以 player 来看的自己的位置，o 代表以 player 来看的对方的位置

●int Duel.GetFieldGroupCount(int player, int s, int o)
同 Duel.GetFieldGroup ，只是返回的是卡的数量

●Group Duel.GetDecktopGroup(int player, int count)
返回玩家 player 的卡组最上方的 count 张卡

●Group Duel.GetExtraTopGroup(int player, int count)
返回玩家 player 的额外卡组表侧表示的卡中最上方的 count 张卡
参考对象：电脑网风暴<42461852>

●Group Duel.GetMatchingGroup(function f|nil, int player, int s, int o, Card|Group ex|nil, ...)
过滤函数，返回以 player 来看的指定位置满足过滤条件 f 并且不等于 ex 的卡
s 代表以 player 来看的自己的位置，o 代表以 player 来看的对方的位置
第6个参数开始为额外参数

●int Duel.GetMatchingGroupCount(function f|nil, int player, int s, int o, Card|Group ex|nil, ...)
过滤函数，返回以 player 来看的指定位置满足过滤条件 f 并且不等于 ex 的卡的数量
s 代表以 player 来看的自己的位置，o 代表以 player 来看的对方的位置
第6个参数开始为额外参数

●Card Duel.GetFirstMatchingCard(function f|nil, int player, int s, int o, Card|Group ex|nil, ...)
过滤函数，返回以 player 来看的指定位置满足过滤条件 f 并且不等于 ex 的第一张卡,没有则返回nil
s 代表以 player 来看的自己的位置，o 代表以 player 来看的对方的位置
第6个参数开始为额外参数

●bool Duel.IsExistingMatchingCard(function f|nil, int player, int s, int o, int count, Card|Group ex|nil, ...)
过滤函数，检查以 player 来看的指定位置是否存在至少 count 张满足过滤条件 f 并且不等于 ex 的卡
s 代表以 player 来看的自己的位置，o 代表以 player 来看的对方的位置
第7个参数开始为额外参数

●Group Duel.SelectMatchingCard(int sel_player, function f|nil, int player, int s, int o, int minc, int maxc, Card|Group ex|nil, ...)
过滤函数，让玩家 sel_player 选择以 player 来看的指定位置满足过滤条件 f 并且不等于 ex 的 minc-maxc 张卡
s 代表以 player 来看的自己的位置，o 代表以 player 来看的对方的位置
第9个参数开始为额外参数

●Group Duel.GetReleaseGroup(int player[, bool use_hand=false])
返回玩家 player 可解放（非上级召唤用）的卡片组， use_hand==true 则包括手卡

●integer Duel.GetReleaseGroupCount(int player[, bool use_hand=false])
返回玩家 player 可解放（非上级召唤用）的卡片数量， use_hand==true 则包括手卡

●bool Duel.CheckReleaseGroup(int player, function f|nil, int count, Card|Group ex|nil, ...)
检查玩家 player 场上是否存在至少 count 张满足过滤条件 f 并且不等于 ex 的可解放的卡（非上级召唤用）
第5个参数开始为额外参数

●Group Duel.SelectReleaseGroup(int sel_player, function f|nil, int minc, int maxc, Card|Group ex|nil, ...)
过滤函数，让玩家sel_player从场上选择 minc-maxc 张满足过滤条件 f 并且不等于 ex 的可解放的卡（非上级召唤用）
第6个参数开始为额外参数

●bool Duel.CheckReleaseGroupEx(int player, function f|nil, int count, Card|Group ex|nil, ...)
检查玩家 player 场上·手卡是否存在至少 count 张满足过滤条件 f 并且不等于 ex 的可解放的卡（非上级召唤用）
第5个参数开始为额外参数

●Group Duel.SelectReleaseGroupEx(int player, function f|nil, int minc, int maxc, Card|Group ex|nil, ...)
过滤函数，让玩家 player 从场上·手卡选择minc-maxc张满足过滤条件 f 并且不等于 ex 的可解放的卡（非上级召唤用）
第6个参数开始为额外参数

●Group Duel.GetTributeGroup(Card c)
返回场上用于通常召唤卡片 c 可解放（上级召唤用）的卡片组

●int Duel.GetTributeCount(Card c[, Group mg|nil, bool ex=false])
返回场上[或 mg 中]用于通常召唤卡片 c 的祭品数量，ex==true 则允许对方场上的怪兽（太阳神之翼神龙-球体形）
此数量不一定等于 Duel.GetTributeGroup 的返回值中的卡片数量
因为某些卡可以作为多个祭品来使用

●Group Duel.CheckTribute(Card c, int minc[, int maxc=minc, Group mg|nil, int toplayer=c:GetControler(), int zone=0x1f])
判断场上[或 mg 中]是否存在用于通常召唤卡片 c[到 toplayer 场上的区域 zone]的 minc[到 maxc]个祭品

●Group Duel.SelectTribute(int player, Card c, int minc, int maxc[, Group mg|nil, int toplayer=player])
让玩家 player 从场上[或 mg 中]选择用于通常召唤卡片 c 的 minc-maxc 个祭品，召唤到 toplayer 场上

●int Duel.GetTargetCount(function f|nil, int player, int s, int o, Card|Group ex|nil, ...)
基本同 Duel.GetMatchingGroupCount ，不同之处在于需要追加判定卡片是否能成为当前正在处理的效果的对象

●bool Duel.IsExistingTarget(function f|nil, int player, int s, int o, int count, Card|Group ex|nil, ...)
基本同 Duel.IsExistingMatchingCard ，不同之处在于需要追加判定卡片是否能成为当前正在处理的效果的对象

●Group Duel.SelectTarget(int sel_player, function f|nil, int player, int s, int o, int minc, int maxc, Card|Group ex|nil, ...)
基本同 Duel.SelectMatchingCard ，不同之处在于此函数会同时将当前正在处理的连锁的对象设置成选择的卡

●Group Duel.SelectFusionMaterial(int player, Card c, Group g[, Card gc|nil, int chkf=PLAYER_NONE, bool not_material=false])
让玩家 player 从卡片组 g 中选择一组[必须包含卡片 gc 在内的]融合怪兽 c 的融合素材
not_material==true 则即使有素材原本不能作为 c 的融合素材，也能判定为那些素材可以凑齐一组 c 的融合素材
(参考对象：次元融合杀<89190953>，团结的剑斗兽<66290900>，奇迹接触<35255456>，新宇融合<14088859>)
##根据c的种类为EFFECT_FUSION_MATERIAL的效果的Operation操作

●void Duel.SetFusionMaterial(Group g)
设置卡片组 g 为需要使用的融合素材

●void Duel.SetSynchroMaterial(Group g)
设置卡片组 g 为需要使用的同调素材

●Group Duel.SelectSynchroMaterial(int player, Card c, function f1|nil, function f2|nil, int minc, int maxc[, Card smat|nil, Group mg|nil])
让玩家 player 从场上[或 mg 中]选择用于同调卡片 c 需要的[必须包含卡片 smat 在内（如果有 mg~=nil 则忽略此参数）]满足条件的一组素材
f1 是 1 只需要满足的过滤条件，f2 是 minc-maxc 只需要满足的过滤条件
f1,f2 之中，至少有一种为调整的条件

●bool Duel.CheckSynchroMaterial(Card c, function f1|nil, function f2|nil, int minc, int maxc[, Card smat|nil, Group mg|nil])
检查场上[或 mg 中]是否存在一组[必须包括卡片 smat 在内的（如果有 mg~=nil 则忽略此参数）]满足条件的卡作为同调召唤卡片 c 的素材
f1 是 1 只需要满足的过滤条件，f2 是 minc-maxc 只需要满足的过滤条件
f1,f2 之中，至少有一种为调整的条件

●Group Duel.SelectTunerMaterial(int player, Card c, Card tuner, function f1|nil, function f2|nil, int minc, int maxc[, Group mg|nil])
让玩家从场上[或 mg 中]选择用于同调召唤卡片 c 需要的满足条件的以卡片 tuner 作为调整的 minc-maxc 张卡的一组素材
f1 是 1 只需要满足的过滤条件，f2 是 minc-maxc 只需要满足的过滤条件

●bool Duel.CheckTunerMaterial(Card c, Card tuner, function f1|nil, function f2|nil, int minc, int maxc[, Group mg|nil])
检查场上[或 mg 中]是否存在一组以卡片 tuner 作为调整,并且满足条件的卡作为同调召唤卡片 c 的素材
f1 是 1 只需要满足的过滤条件，f2 是 minc-maxc 只需要满足的过滤条件

●Group Duel.GetRitualMaterial(int player)
返回玩家 player 可用的用于仪式召唤素材的卡片组
包含手上，场上可解放的以及墓地的仪式魔人等卡

●void Duel.ReleaseRitualMaterial(Group g)
解放仪式用的素材卡片组 g，如果是墓地的仪式魔人等卡则除外

●Group,Group Duel.GetFusionMaterial(int player[,int location=LOCATION_HAND+LOCATION_MZONE])
第一个返回值是 玩家 player  [在区域 location 内的]可用的用于融合召唤素材的卡片组(包含受 EFFECT_EXTRA_FUSION_MATERIAL 效果影响的卡)
第二个返回值是 只包含 手卡、怪兽区[、除外、墓地、卡组、额外卡组、P区·魔陷区原本种类是]怪兽卡的卡片组(也即是没有包含受 EFFECT_EXTRA_FUSION_MATERIAL 效果影响的卡)

●bool Duel.IsSummonCancelable()
检测能否取消召唤(?)

●void Duel.SetSelectedCard(Card|Group targets)
将 targets 设置为已选择的卡（？）

●Group Duel.GrabSelectedCard()
获取已选择的卡并返回，同时将已选择的卡清除（？）

●void Duel.SetTargetCard(Card|Group targets)
把当前正在处理的连锁的对象设置成 targets
注，这里的对象指的的广义的对象，包括不取对象的效果可能要处理的对象

●void Duel.ClearTargetCard()
把当前正在处理的连锁的对象全部清除

●void Duel.SetTargetPlayer(int player)
把当前正在处理的连锁的对象玩家设置成 player 

●void Duel.SetTargetParam(int param)
把当前正在处理的连锁的对象参数设置成 param 

●void Duel.SetOperationInfo(int chainc, int category, Card|Group targets, int count, int target_player, int target_param)
设置连锁 chainc 的操作信息此操作信息包含了效果处理中确定要处理的效果分类。 chainc==0 表示当前连锁
比如潜行狙击手需要设置 CATEGORY_DICE，但是不能设置 CATEGORY_DESTROY，因为不确定
对于破坏效果，targets 需要设置成发动时可能成为连锁的影响对象的卡，
并设置 count 为发动时确定的要处理的卡的数量
比如黑洞发动时，targets 需要设定为场上的所有怪兽，count 设置成场上的怪的数量
对于需要移动卡片位置的 CATEGORY_SPECIAL_SUMMON,CATEGORY_TOHAND,CATEGORY_TODECK 等分类，
如果要处理的卡是确定的（比如取对象），则设置 targets 为这些卡，count 为数量，
如果要处理的卡是不确定的（效果处理时才能确定，一般是不取对象的效果），
	则设置 targets 为nil，count 为预计要处理的卡的数量，
	target_player 为预计要处理的卡的持有者（不确定就为0）
	target_param 为预计要处理的卡的位置
例如增援：Duel.SetOperationInfo(0,CATEGORY_TOHAND,nil,1,tp,LOCATION_DECK)
操作信息用于很多效果的发动的检测，例如星尘龙，王家长眠之谷等
--特别注意：如果 category 是 CATEGORY_DRAW ，那 target_param 代表要抽的数量。抽卡的效果通常要用到 Duel.SetTargetPlayer 和 Duel.SetTargetParam
例如 强欲之壶： 
	Duel.SetTargetPlayer(tp)
	Duel.SetTargetParam(2)
	Duel.SetOperationInfo(0,CATEGORY_DRAW,nil,0,tp,2)


●bool[,Card|Group,int,int,int] Duel.GetOperationInfo(int chainc, int category)
返回连锁 chainc 的category分类的操作信息，存在的话，则返回值为5个， chainc==0 则是表示当前连锁
第一个返回值是false的话表示不存在该分类
后4个返回值对应Duel.SetOperationInfo的后4个参数：Card|Group targets, int count, int target_player, int target_param

●int Duel.GetOperationCount(int chainc)
返回连锁 chainc 包含的操作分类的数量
chainc==0 表示当前连锁

●void Duel.ClearOperationInfo(int chainc)
清除连锁 chainc 的所有操作分类
chainc==0 表示当前连锁

●bool Duel.CheckXyzMaterial(Card c, function f|nil, int lv, int minc, int maxc, Group mg|nil)
检查场上[或 mg 中]是否存在用于超量召唤卡片 c 的超量用等级为 lv 的 minc-maxc 个满足过滤条件 f 的叠放素材

●Group Duel.SelectXyzMaterial(int player, Card c, function f|nil, int lv, int minc, int maxc[, Group mg|nil])
让玩家 player 为超量怪兽 c 从场上[或 mg 中]选择超量用等级为 lv 的 minc-maxc 个满足条件f的叠放素材

●void Duel.Overlay(Card c, Card|Group ocard)
把卡片(组) ocard 作为卡片 c 的叠放卡叠放

●Group Duel.GetOverlayGroup(int player, int s, int o)
返回以 player 来看的指定位置的所有叠放的卡
s 代表以 player 来看的自己的位置，o 代表以 player 来看的对方的位置

●int Duel.GetOverlayCount(int player, int s, int o)
返回以 player 来看的指定位置的所有叠放的卡的数量
s 代表以 player 来看的自己的位置，o 代表以 player 来看的对方的位置

●bool Duel.CheckRemoveOverlayCard(int player, int s, int o, int count, int reason)
检查 player 能否以原因 reason 移除以 player 来看的指定位置至少 count 张卡
s 代表以 player 来看的自己的位置，o 代表以 player 来看的对方的位置

●int Duel.RemoveOverlayCard(int player, int s, int o, int minc, int maxc, int reason)
让player以 reason 原因移除以 player 来看的指定位置的 minc-maxc 张叠放卡，返回值表示取除的数量
s 代表以 player 来看的自己的位置，o 代表以 player 来看的对方的位置

●void Duel.Hint(int hint_type, int player, int desc)
给玩家 player 发送 hint_type 类型的消息提示，提示内容为 desc
#hint_type只能为以下类型：
#HINT_SELECTMSG		将提示内容写入缓存，用于选择卡片的提示，例如Duel.SelectMatchingCard等
#HINT_OPSELECTED	向player提示“对方选择了：...”，常用于向对方玩家提示选择发动了什么效果
#HINT_CARD			此时desc应为卡号，手动显示卡片发动的动画，常用于提示不入连锁的处理
#HINT_RACE			此时desc应为种族，向player提示“对方宣言了：...”种族
#HINT_ATTRIB		此时desc应为属性，向player提示“对方宣言了：...”属性
#HINT_CODE			此时desc应为卡号，向player提示“对方宣言了：...”卡片
#HINT_NUMBER		此时desc视为单纯的数字，向player提示“对方选择了：...”数字
#HINT_MESSAGE		弹出一个对话框显示信息
#HINT_EVENT			将提示内容写入缓存，用于时点的提示信息（诱发即时效果的提示）
#HINT_EFFECT		同HINT_CARD

●void Duel.HintSelection(Group g)
手动为卡片组 g 显示被选为对象的动画效果，并记录这些卡被选为对象(广义的)

●bool Duel.SelectEffectYesNo(int player, Card c[, int desc=95])
让玩家 player 选择是否发动卡片c的效果[，提示文字可以自行用 desc 替换，desc 用 aux.Stringid 获取]

●bool Duel.SelectYesNo(int player, int desc)
让玩家 player 选择是或否，描述为 desc

●int Duel.SelectOption(int player, int desc1, ...)
让玩家选择选项，从第二个参数开始，每一个参数代表一条选项
返回选择的选项的序号(从0开始)

●void Duel.SelectSequence()
看函数名字，像是选择序号的
但是此函数只有一个 check_action_permission(L) 操作，还没有返回值，不知何用

●int Duel.SelectPosition(int player, Card c, int pos)
让玩家 player [从 pos 中]选择卡片 c 的表示形式。返回值为选的形式的值
注意：此函数并不会实际改变表示形式

●int Duel.SelectField(int player, int count, int s, int o, int filter)
让玩家 player 选择指定位置(s 和 o)中 filter 以外的 count 个格子，并返回选择位置的代码
s 代表以 player 来看的自己的位置，o 代表以 player 来看的对方的位置
不能选择 已被使用 的ex格子
代码返回的是一个32位的 int 值，前面的16位是 player 来看的对方的位置的代码，后面16位是 player 来看的自己的位置的代码
两部分16位里，前面8位是魔陷区，后面8位是怪兽区
比如 Duel.SelectField(tp,3,LOCATIOIN_ONFIELD,LOCATIOIN_SZONE,0x2000160) 表示从己方的场上 和 对方的 魔陷区选3个格子，不能选额外怪兽区和自己的左边第一个魔陷区还有对方的场地区

●int Duel.SelectDisableField(int player, int count, int s, int o, int filter)
让玩家 player 选择指定位置(s 和 o)中filter以外的count个格子，并返回选择位置的代码
s 代表以 player 来看的自己的位置，o 代表以 player 来看的对方的位置
注意这个函数并不会实际无效所选格子
常用于选择区域不能使用

●int Duel.AnnounceRace(int player, int count, int available)
让玩家 player 从可选的种族中宣言 count 个种族
available 是所有可选种族的组合值，可以自行组合
可以直接将名字相加，比如 RACE_WARRIOR+RACE_SPELLCASTER
RACE_ALL			=0x1ffffff	--全种族
RACE_WARRIOR		=0x1		--战士
RACE_SPELLCASTER	=0x2		--魔法师
RACE_FAIRY			=0x4		--天使
RACE_FIEND			=0x8		--恶魔
RACE_ZOMBIE			=0x10		--不死
RACE_MACHINE		=0x20		--机械
RACE_AQUA			=0x40		--水
RACE_PYRO			=0x80		--炎
RACE_ROCK			=0x100		--岩石
RACE_WINDBEAST		=0x200		--鸟兽
RACE_PLANT			=0x400		--植物
RACE_INSECT			=0x800		--昆虫
RACE_THUNDER		=0x1000		--雷
RACE_DRAGON			=0x2000		--龙
RACE_BEAST			=0x4000		--兽
RACE_BEASTWARRIOR	=0x8000		--兽战士
RACE_DINOSAUR		=0x10000	--恐龙
RACE_FISH			=0x20000	--鱼
RACE_SEASERPENT		=0x40000	--海龙
RACE_REPTILE		=0x80000	--爬虫类
RACE_PSYCHO			=0x100000	--念动力
RACE_DEVINE			=0x200000	--幻神兽
RACE_CREATORGOD		=0x400000	--创造神
RACE_WYRM			=0x800000	--幻龙
RACE_CYBERSE		=0x1000000	--电子界

●int Duel.AnnounceAttribute(int player, int count, int available)
让玩家 player 从可选的属性中宣言 count 个属性
available 是所有可选属性的组合值，可以自行组合，可以直接将名字相加
ATTRIBUTE_EARTH		=0x01		--地
ATTRIBUTE_WATER		=0x02		--水
ATTRIBUTE_FIRE		=0x04		--炎
ATTRIBUTE_WIND		=0x08		--风
ATTRIBUTE_LIGHT		=0x10		--光
ATTRIBUTE_DARK		=0x20		--暗
ATTRIBUTE_DEVINE	=0x40		--神

●int Duel.AnnounceLevel(int player[, int min=1, int max=12, ...])
让玩家宣言一个[minc-maxc]等级并返回
第四个参数开始，表示要排除的等级

●int Duel.AnnounceCard(int player[, ...])
让玩家 player 宣言一个卡片（比如：禁止令）
Duel.AnnounceCardFilter 已经被合并到这个函数里
如果参数只有2个，会自动加上第三个参数 OPCODE_ISTYPE
多个参数参考 古代的齿车机械(18486927):
	local code=e:GetHandler():GetCode()
	--c:IsSetCard(0x51) and not c:IsCode(code)
	getmetatable(e:GetHandler()).announce_filter={0x51,OPCODE_ISSETCARD,code,OPCODE_ISCODE,OPCODE_NOT,OPCODE_AND}
	local ac=Duel.AnnounceCard(tp,table.unpack(getmetatable(e:GetHandler()).announce_filter))
--Opcode
OPCODE_ADD				=0x40000000 --加法
OPCODE_SUB				=0x40000001 --减法
OPCODE_MUL				=0x40000002 --乘法
OPCODE_DIV				=0x40000003 --除法
OPCODE_AND				=0x40000004 --与
OPCODE_OR				=0x40000005 --或
OPCODE_NEG				=0x40000006 
OPCODE_NOT				=0x40000007 --非
OPCODE_ISCODE			=0x40000100 --卡片过滤条件为code
OPCODE_ISSETCARD		=0x40000101 --卡片过滤条件为setname
OPCODE_ISTYPE			=0x40000102 --卡片过滤条件为type
OPCODE_ISRACE			=0x40000103 --卡片过滤条件为race
OPCODE_ISATTRIBUTE		=0x40000104 --卡片过滤条件为attribute

●int Duel.AnnounceType(int player)
让玩家 player 宣言一个卡片类型（怪兽·魔法·陷阱）
别想着直接宣言 复合类型（永续魔法 等）

●int,int Duel.AnnounceNumber(int player, int number, ...)
让玩家 player 宣言一个数字
从第二个参数开始，每一个参数代表一个可宣言的数字
第一个返回值是宣言的数字，第二个返回值是宣言数字在所有选项中的位置

●int Duel.AnnounceCoin(int player)
让玩家 player 宣言硬币的正反面

●int[,...] Duel.TossCoin(int player, int count)
让玩家 player 投 count(<=5)次硬币，返回值为 count 个结果，0或者1, 正面是 1，反面是 0

●int[,...] Duel.TossDice(int player, int count1[, int count2 = 0])
让玩家 player 投 count1 次骰子[，1-player投count2次骰子](count1+count2<=5)
返回值为 count1+count2 个结果，1-6

●int Duel.RockPaperScissors([bool repeat=true])
猜拳，若 repeat==false 则只猜一次；否则就是直到分出胜负为止。返回胜利的玩家号码

●int,int,int,int,int Duel.GetCoinResult()
返回当前投硬币的结果

●int,int,int,int,int Duel.GetDiceResult()
返回当前掷骰子的结果

●void Duel.SetCoinResult(int res, ... )
强行修改投硬币的结果为 res ,最多5个参数，res 只能是 0 或 1, ，其他全算作 0
此函数用于永续的EVENT_TOSS_COIN事件中

●void Duel.SetDiceResult(int res, ...)
强行修改投骰子的结果为 res ,最多5个参数，res 只能是 1~255, ，其他数字全算作 1
此函数用于永续的EVENT_TOSS_DICE事件中

●Effect|nil,... Duel.IsPlayerAffectedByEffect(int player, int code)
检查玩家 player 是否受到种类为 code 的效果影响，如果有就返回那些效果，没有则返回nil ,player 为0和1以外的数值时，也会返回nil

●bool Duel.IsPlayerCanDraw(int player[, int count=0])
检查玩家 player 是否可以效果抽[count 张]卡

●bool Duel.IsPlayerCanDiscardDeck(int player, int count)
检查玩家 player 是否可以把卡组顶端 count 张卡送去墓地

●bool Duel.IsPlayerCanDiscardDeckAsCost(int player, int count)
检查玩家 player 能否把卡组顶端 count 张卡送去墓地作为cost

●bool Duel.IsPlayerCanSummon(int player[, int sumtype, Card c])
检查玩家 player 是否可以通常召唤[c，以 sumtype 方式]
如果需要可选参数，则必须全部使用
仅当玩家受到“不能召唤”等效果的影响时返回false

●bool Duel.IsPlayerCanMSet(int player[, int sumtype, Card c])
检查玩家 player 是否可以盖放怪兽[c，以sumtype方式]
如果需要可选参数，则必须全部使用

●bool Duel.IsPlayerCanSSet(int player[, Card c])
检查玩家 player 是否可以把卡片[ c ]盖放到魔陷区

●bool Duel.IsPlayerCanSpecialSummon(int player[, int sumtype, int sumpos, int target_player, Card c])
检查玩家 player 能否特殊召唤[卡片 c 到 target_player 场上，以 sumtype 召唤方式，sumpos 表示形式]
如果需要可选参数，则必须全部使用

●bool Duel.IsPlayerCanFlipSummon(int player[, Card c])
检查玩家 player 是否可以反转召唤[卡片 c]

●bool Duel.IsPlayerCanSpecialSummonMonster(int player, int code, int setcode|nil, int type|nil, int atk|nil, int def|nil, int level|nil, int race|nil, int attribute|nil
	[, int  pos=POS_FACEUP, int target_player=player, int sumtype=0])
检查玩家 player 是否可以[以 sumtype 方式][以 pos 表示形式]特殊召唤 给定参数的怪兽到 target_player 场上
此函数通常用于判定是否可以特招token和陷阱怪兽

●bool Duel.IsPlayerCanSpecialSummonCount(int player, int count)
检查玩家 player 能否特殊召唤 count 次

●bool Duel.IsPlayerCanRelease(int player[, Card c])
检查玩家 player 是否能解放[卡片 c]

●bool Duel.IsPlayerCanRemove(int player[, Card c, int reason=REASON_EFFECT])
检查玩家 player 是否能[以 reason 原因]除外[卡片 c]

●bool Duel.IsPlayerCanSendtoHand(int player[, Card c])
检查玩家是否能把卡片[c]送去手牌

●bool Duel.IsPlayerCanSendtoGrave(int player[, Card c])
检查玩家是否能把卡片[c]送去墓地

●bool Duel.IsPlayerCanSendtoDeck(int player[, Card c])
检查玩家是否能把卡片[c]送去卡组

●bool Duel.IsPlayerCanAdditionalSummon(int player)
检查玩家是否可以额外的增加通常召唤次数。(宝石骑士·斜绿 等)
适用过相同效果的场合返回false
注：以前这个函数叫 Duel.IsPlayerExtraSummoned(int player)

●bool Duel.IsChainNegatable(int chainc)
检查连锁 chainc 的发动能否被无效

●bool Duel.IsChainDisablable(int chainc)
检查连锁 chainc 的效果能否被无效

●bool Duel.CheckChainTarget(int chainc, Card c)
检查卡片 c 是否是连锁 chainc 的效果的正确的对象
chainc==0 表示当前连锁

●bool Duel.CheckChainUniqueness()
检查当前连锁中是否存在同名卡的发动，返回true表示无同名卡

●int,... Duel.GetActivityCount(int player, int activity_type, ...)
返回玩家 player 进行对应的 activity_type 操作的次数
activity_type 为以下类型
ACTIVITY_SUMMON         =1	--召唤（不包括通常召唤的放置）
ACTIVITY_NORMALSUMMON   =2	--通常召唤（包括通常召唤的放置）
ACTIVITY_SPSUMMON       =3	--特殊召唤
ACTIVITY_FLIPSUMMON     =4	--反转召唤
ACTIVITY_ATTACK         =5	--攻击
ACTIVITY_BATTLE_PHASE   =6	--进入战斗阶段

●bool Duel.CheckPhaseActivity()
检查玩家在当前阶段是否有操作（是否处于阶段开始时，如七皇之剑）

●void Duel.AddCustomActivityCounter(int counter_id, int activity_type, function f)
设置操作类型为 activity_type、代号为 counter_id 的计数器，放在 initial_effect 函数内
f 为过滤函数，以Card类型为参数，返回值为 false 的卡片进行以下类型的操作，计数器增加1
activity_type 为以下类型
ACTIVITY_SUMMON         =1	--召唤（不包括通常召唤的set）
ACTIVITY_NORMALSUMMON   =2	--通常召唤（包括通常召唤的set）
ACTIVITY_SPSUMMON       =3	--特殊召唤
ACTIVITY_FLIPSUMMON     =4	--反转召唤
ACTIVITY_ATTACK         =5	--攻击
ACTIVITY_CHAIN          =7	--发动效果

●int Duel.GetCustomActivityCount(int counter_id, int player, int activity_type)
返回 player 进行以下操作的代号为 counter_id 的计数器的次数
activity_type 为以下类型
ACTIVITY_SUMMON         =1	--召唤（不包括通常召唤的set）
ACTIVITY_NORMALSUMMON   =2	--通常召唤（包括通常召唤的set）
ACTIVITY_SPSUMMON       =3	--特殊召唤
ACTIVITY_FLIPSUMMON     =4	--反转召唤
ACTIVITY_ATTACK         =5	--攻击
ACTIVITY_CHAIN          =7	--发动效果

●int Duel.GetBattledCount(int player)
返回玩家 player 这回合战斗过的次数 

●bool Duel.IsAbleToEnterBP()
检查回合玩家能否进入战斗阶段

●void Duel.SwapDeckAndGrave(int player)
现世与冥界的逆转专用。把玩家 player 的卡组和墓地交换

●void Duel.MajesticCopy(Card c1, Card c2)
救世星龙专用。把卡片 c2 记述的效果复制给卡片 c1 
强制发动的效果可以选择是否发动

========== aux ============
##只说明常用的函数
●int aux.Stringid(int code, int id)
用于索引卡号为code的卡片第id个（从0开始）效果提示

●Card aux.Next(Group g)
卡片组 g 的迭代器，指针会先指向第一张卡，然后每次调用这函数指向下一张卡，通常用在需要对g中的卡片进行操作的时候
例如：
	local g=Group.CreateGroup()
	for tc in aux.Next(g) do
	end
等价于：
	local g=Group.CreateGroup()
	local tc=g:GetFirst()
	while tc do
		tc=g:GetNext()
	end

●void aux.NULL()
就是1个空函数

●bool aux.TRUE()
return true

●bool aux.FALSE()
return false

●void aux.BeginPuzzle()
开始残局
##此函数注册3个全局效果：
##回合结束时玩家的基本分变成0
##跳过玩家抽卡阶段与准备阶段

●bool aux.IsDualState(Effect e)
检查二重怪兽 e:GetHandler()是否是再度召唤状态（用于效果的Condition属性）
常用于二重怪兽再度召唤获得的效果 e 的Condition属性

●bool aux.IsNotDualState(Effect e)
aux.IsDualState的反义（用于效果的Condition属性）

●bool aux.DualNormalCondition(Effect e)
检查二重怪兽 e:GetHandler()是否为被视为通常怪兽的状态（用于效果的Condition属性）

●void aux.EnableDualAttribute(Card c)
为卡片 c 添加二重怪兽属性

●void aux.EnableSpiritReturn(Card c, int event1,...)
为卡片 c 添加灵魂怪兽结束阶段回到手卡的效果（发生事件event1,...的回合，结束阶段回到手卡）

●bool aux.IsUnionState(Effect e)
检查同盟怪兽 e:GetHandler()是否处于同盟装备的状态（用于效果的Condition属性）

●void aux.SetUnionState(Card c)
为卡片 c 添加同盟状态

●bool aux.CheckUnionEquip(Card uc, Card tc)
检查同盟怪兽 uc 能否作为同盟装备在怪兽tc上

●bool aux.EnableUnionAttribute(Card c, function uf)
为卡片 c 添加同盟属性，uf 为限定装备对象的同盟条件，原型为：
bool function (Effect e, Card c) end

●Effect, Effect aux.EnableChangeCode(Card c, int code,int location , function con_func)
让卡片 c 的卡名在满足条件 con_func 的场合，在 location 区域变成 code ,此函数返回2个 Effect 
默认区域根据 c 的原本种类决定
参考对象：武装龙·雷电 LV10<58153103>

●function aux.TargetEqualFunction(function f, any value, ...)
一般用在效果注册里,返回的是一个 有 bool 返回值类型的 函数，第3个参数开始为额外参数
function aux.TargetEqualFunction(f,value,...)
	local ext_params={...}
	return	function(effect,target)
				return f(target,table.unpack(ext_params))==value
			end
end

●function aux.TargetBoolFunction(function f,...)
一般用在效果注册里,返回的是一个 有 bool 返回值类型的 函数，第2个参数开始为额外参数
function aux.TargetBoolFunction(f,...)
	local ext_params={...}
	return	function(effect,target)
				return f(target,table.unpack(ext_params))
			end
end

●function aux.FilterEqualFunction(function f, any value, ...)
用于过滤满足单一过滤条件 f ,且值为 value 的卡,,返回的是一个 有 bool 返回值类型的 函数， 第3个参数开始为额外参数
function aux.FilterEqualFunction(f,value,...)
	local ext_params={...}
	return	function(target)
				return f(target,table.unpack(ext_params))==value
			end
end

●function aux.FilterBoolFunction(function f, ...)
用于过滤满足单一过滤条件 f 的卡,,返回的是一个 有 bool 返回值类型的 函数，第2个参数开始为额外参数
function aux.FilterBoolFunction(f,...)
	local ext_params={...}
	return	function(target)
				return f(target,table.unpack(ext_params))
			end
end

●function aux.Tuner(function f, ...)
用于过滤满足单一过滤条件 f 的调整，,返回的是一个 有 bool 返回值类型的 函数，只要求是 调整怪兽的话，就写 aux.Tuner(nil)
第2个参数开始为额外参数

●function aux.NonTuner(function f, ...)
用于过滤满足单一过滤条件 f 的调整以外的卡，,返回的是一个 有 bool 返回值类型的 函数，只要求是 调整以外的怪兽的话，就写 aux.NonTuner(nil)
第2个参数开始为额外参数

●Card|Group|Effect|int|bool|string|nil|function|table|any aux.GetValueType(any value)
返回 value 在lua中的type

●Group aux.GetMustMaterialGroup(int player , int code)
如果 player 受到效果种类 code 影响，则返回受到影响的卡
目前代码中涉及的code有 EFFECT_MUST_BE_SMATERIAL, EFFECT_MUST_BE_XMATERIAL, EFFECT_MUST_BE_FMATERIAL, EFFECT_MUST_BE_LMATERIAL ,都是 必须成为素材的效果

●bool aux.MustMaterialCheck(Card|Group value, int player , int code)
检查 value 中是否有 player 受到效果种类 code 影响的卡或者卡片组
目前代码中涉及的code有 EFFECT_MUST_BE_SMATERIAL, EFFECT_MUST_BE_XMATERIAL, EFFECT_MUST_BE_FMATERIAL, EFFECT_MUST_BE_LMATERIAL ,都是 必须成为素材的检测

●bool aux.MustMaterialCounterFilter(Card c, Group g)
如果 g 中 包含 c ，则返回 false

●void aux.AddSynchroProcedure(Card c, function f1|nil, function f2|nil, int minc[, int maxc=99])
为卡片 c 添加同调召唤手续
f1 为 1 只满足的过滤条件，并且必须为调整；f2 为 minc [~ maxc]只满足的过滤条件

●void aux.AddSynchroProcedure2(Card c, function f1, function f2)
等价于aux.AddSynchroProcedure(c,f1,f2,1,1)

●void aux.AddSynchroMixProcedure(Card c, function f1|nil, function f2|nil, function f3|nil, function f4|nil, int minc, int maxc)
为卡片 c 添加同调召唤手续，
f1,f2,f3 为 1 只满足的过滤条件，f4 为 minc ~ maxc 只满足的过滤条件
f1,f2,f3,f4 之中，至少有一种为调整
4种过滤函数的原型如下：
bool function f1(Card c, Card syncard) end -- syncard 表示要同调召唤的这张卡。为了避免可能遇到的错误，哪怕用不上，也建议写上，下面这3个的其他参数也是同样的原因
bool function f2(Card c, Card syncard, Card c1) end -- c1 由 f1 函数里传入
bool function f3(Card c, Card syncard, Card c1, Card c2) end -- c1 由 f1 函数里传入， c2 由 f2 函数传入
bool function f4(Card c, Card syncard, Card c1, Card c2, Card c3) end -- c1 由 f1 函数里传入， c2 由 f2 函数传入， c3 由 f3 函数传入

●function aux.TuneMagicianFilter(Card c, Effect e)
调弦之魔术师(73941492)专用，,返回的是一个 有 bool 返回值类型的 函数 f(e,c)

●function aux.TuneMagicianCheckX(Card c, Group sg, Effect e)
调弦之魔术师(73941492)专用

●void aux.AddXyzProcedure(Card c, function f|nil, int lv, int ct[, function alterf|nil, int desc|nil, int maxc=ct, function op|nil])
为卡片 c 添加超量召唤手续
用满足条件 f 的等级为 lv 的 ct[-maxc] 只怪兽进行叠放
或者在单个怪兽（通常是超量怪兽）上叠放
alterf 为这个怪兽满足的条件，desc 为描述，op 为叠放时需要的操作（比如 希望皇龙）

●void aux.AddXyzProcedureLevelFree(Card c, function f|nil, function gf|nil, int minc, int maxc[, function alterf|nil, int desc|nil, function op|nil])
为卡片 c 添加超量召唤手续
用满足条件 f 的卡片组里，满足 gf 的 minc[-maxc] 只怪兽进行叠放，f 为必要条件，gf 为额外条件
或者在单个怪兽（通常是超量怪兽）上叠放
alterf为这个怪兽满足的条件，desc为描述，op为叠放时需要的操作（比如 闪光No.0 希望之异热同心）
参数 f 的函数原型为 function f(Card c, Card xyzc) end **** c 为各个超量素材要满足的条件， xyzc 表示要超量召唤的卡
参数 gf 的函数原型为 function gf(Croup g) end

●void aux.AddFusionProcMix(Card c, bool sub, bool insf, ...)
为卡片 c 添加融合召唤手续
用额外参数里的卡各1张为融合素材,额外参数的类型 可以是 function 或者 卡密(int code),
sub表示能否使用融合代替素材，insf==false 表示必须用素材融合召唤。若这只怪兽融合召唤只能使用上述的卡进行，sub 和 insf 都要填 false
#以下融合函数这2个参数相同

●void aux.AddFusionProcMixRep(Card c, bool sub, bool insf, (function f1)|(int code1), int minc, int maxc, ...)
为c 添加融合召唤手续
用满足f1 的怪兽 minc-maxc 只，和 额外参数里 各1只的怪兽为融合素材,
额外参数的类型 可以是 function 或者 卡密(int code)
sub表示能否使用融合代替素材，insf==false 表示必须用素材融合召唤。若这只怪兽融合召唤只能使用上述的卡进行，sub 和 insf 都要填 false

●void aux.AddFusionProcCode2(Card c, int code1, int code2, bool sub, bool insf)
为c 添加融合召唤手续
用卡号为code1和code2的2只怪兽为融合素材
sub表示能否使用融合代替素材，insf==false 表示必须用素材融合召唤。若这只怪兽融合召唤只能使用上述的卡进行，sub 和 insf 都要填 false
等价于 aux.AddFusionProcMix(c,sub,insf,code1,code2)

●void aux.AddFusionProcCode3(Card c, int code1, int code2, int code3, bool sub, bool insf)
为c 添加融合召唤手续
用卡号为code1,code2,code3的3只怪兽为融合素材
sub表示能否使用融合代替素材，insf==false 表示必须用素材融合召唤。若这只怪兽融合召唤只能使用上述的卡进行，sub 和 insf 都要填 false
等价于 aux.AddFusionProcMix(c,sub,insf,code1,code2,code3)

●void aux.AddFusionProcCode4(Card c, int code1, int code2, int code3, int code4, bool sub, bool insf)
为c 添加融合召唤手续
用卡号为code1,code2,code3,code4的4只怪兽为融合素材
sub表示能否使用融合代替素材，insf==false 表示必须用素材融合召唤。若这只怪兽融合召唤只能使用上述的卡进行，sub 和 insf 都要填 false
等价于 aux.AddFusionProcMix(c,sub,insf,code1,code2,code4)

●void aux.AddFusionProcCodeRep(Card c, int code, int cc, bool sub, bool insf)
为c 添加融合召唤手续
用 cc 个卡号为 code 的怪兽为融合素材
sub表示能否使用融合代替素材，insf==false 表示必须用素材融合召唤。若这只怪兽融合召唤只能使用上述的卡进行，sub 和 insf 都要填 false
等价于 aux.AddFusionProcMix(c,sub,insf,table.unpack(tcode)) ,tcode 是包含 cc 个 code 的表

●void aux.AddFusionProcCodeRep2(Card c, int code, int minc, int maxc, bool sub, bool insf)
为c 添加融合召唤手续
用 minc-maxc 个卡号为 code 的怪兽为融合素材
sub表示能否使用融合代替素材，insf==false 表示必须用素材融合召唤。若这只怪兽融合召唤只能使用上述的卡进行，sub 和 insf 都要填 false
等价于 aux.AddFusionProcMixRep(c,sub,insf,code1,minc,maxc)

●void aux.AddFusionProcCodeFun(Card c, int code, function f, int cc, bool sub, bool insf)
为c 添加融合召唤手续
用卡号为 code 的1只怪兽，和 cc 个满足条件 f 的怪兽为融合素材
sub表示能否使用融合代替素材，insf==false 表示必须用素材融合召唤。若这只怪兽融合召唤只能使用上述的卡进行，sub 和 insf 都要填 false
等价于 aux.AddFusionProcMix(c,sub,insf,code1,table.unpack(fun)),fun 是包含 cc 个 满足条件 f 的卡的表

●void aux.AddFusionProcFun2(Card c, function f1, function f2, bool insf)
为c 添加融合召唤手续
用满足条件 f1 与 f2 的怪兽 各1只为融合素材
insf==false 表示必须用素材融合召唤
等价于 aux.AddFusionProcMix(c,false,insf,f1,f2)

●void aux.AddFusionProcFunRep(Card c, function f, int cc, bool insf)
为c 添加融合召唤手续
用 cc 个 满足相同条件 f 的怪兽为融合素材
insf==false 表示必须用素材融合召唤
等价于 aux.AddFusionProcMix(c,false,insf,table.unpack(fun)),fun 是包含 cc 个 满足条件 f 的卡的表

●void aux.AddFusionProcFunRep2(Card c, function f, int minc, int maxc, bool insf)
为c 添加融合召唤手续
用 minc-maxc 个 满足相同条件 f 的怪兽为融合素材
insf==false 表示必须用素材融合召唤
等价于 aux.AddFusionProcMixRep(c,false,insf,f,minc,maxc)

●void aux.AddFusionProcFunFun(Card c, function f1, function f2, int cc, bool insf)
为c 添加融合召唤手续
用满足过滤条件 f1 的1只怪兽 ，和满足过滤条件 f2 的 cc 只怪兽为融合素材
insf==false 表示必须用素材融合召唤
等价于 aux.AddFusionProcMix(c,false,insf,f1,table.unpack(fun)),fun 是包含 cc 个 满足条件 f2 的卡的表

●void aux.AddFusionProcFunFunRep(Card c, function f1, function f2, int minc, int maxc, bool insf)
为c 添加融合召唤手续
用满足过滤条件 f1 的1只怪兽 ，和满足过滤条件 f2 的 minc-maxc 只怪兽为融合素材
insf==false 表示必须用素材融合召唤
等价于 aux.AddFusionProcMixRep(c,false,insf,f2,minc,maxc,f1)

●void aux.AddFusionProcCodeFunRep(Card c, int code, function f, int minc, int maxc, bool sub, bool insf)
为c 添加融合召唤手续
用卡号为 code 的1只怪兽 ，和满足过滤条件 f 的 minc-maxc 只怪兽为融合素材
sub表示能否使用融合代替素材，insf==false 表示必须用素材融合召唤。若这只怪兽融合召唤只能使用上述的卡进行，sub 和 insf 都要填 false
等价于 aux.AddFusionProcMixRep(c,sub,insf,f,minc,maxc,code1)

●void aux.AddFusionProcCode2FunRep(Card c, int code1, int code2, function f, int minc, int maxc, bool sub, bool insf)
为c 添加融合召唤手续
用卡号为 code1,code2 的各1只怪兽 ，和满足过滤条件 f 的 minc-maxc 只怪兽为融合素材
sub表示能否使用融合代替素材，insf==false 表示必须用素材融合召唤。若这只怪兽融合召唤只能使用上述的卡进行，sub 和 insf 都要填 false
等价于 aux.AddFusionProcMixRep(c,sub,insf,f,minc,maxc,code1,code2)

●void aux.AddFusionProcShaddoll(Card c, int attribute)
影依融合怪兽专用，attribute 为需要的属性

●Effect aux.AddContactFusionProcedure(Card c, function filter, int self_location, int opponent_location, any mat_operation[, ...])
为c 添加接触融合手续。
filter 表示素材的过滤条件
self_location, opponent_location 表示以 c:GetControler() 来看的自己，对方的区域
mat_operation 表示要对素材进行的操作

●Effect aux.AddRitualProcUltimate(Card c, function filter, function level_function, string greater_or_equal, int summon_location=LOCATION_HAND, function grave_filter, function mat_filter)
为卡片 c 添加仪式召唤效果
filter 为仪式怪兽满足的条件， level_function 表示仪式召唤要满足的等级(返回值为int类型的函数)
greater_or_equal 的值只有 "Greater" 和 "Equal"
summon_location 表示从哪里仪式召唤(默认是手卡)
grave_filter 表示 作为解放代替除外墓地  的仪式素材需要满足的条件
mat_filter 表示仪式素材要满足的条件

●bool aux.RitualUltimateFilter(Card c, function filter, Effect e, int tp, Group m1, Group m2, function level_function, string greater_or_equal, bool chk)
仪式素材检测。检测 m1 和 m2 中是否存在满足条件的用于仪式召唤 c 的素材。m1 必须要有
filter 为仪式怪兽满足的条件， level_function 表示仪式召唤要满足的等级(返回值为int类型的函数)
greater_or_equal 的值只有 "Greater" 和 "Equal"
chk 这个参数似乎不是必须要有

●void aux.AddRitualProcGreater(Card c, function filter, int summon_location=LOCATION_HAND, function grave_filter, function mat_filter)
为卡片 c 添加仪式召唤效果
filter 为仪式怪兽满足的条件，素材的仪式等级之和要 刚好 大于或者等于仪式怪兽的原本等级
summon_location 表示从哪里仪式召唤(默认是手卡)
grave_filter 表示 作为解放代替除外墓地  的仪式素材需要满足的条件
mat_filter 表示仪式素材要满足的条件
等价于：aux.AddRitualProcUltimate(c,filter,Card.GetOriginalLevel,"Greater",summon_location,grave_filter,mat_filter)

●void aux.AddRitualProcGreaterCode(Card c, int code1, int summon_location=LOCATION_HAND, function grave_filter, function mat_filter)
为卡片 c 添加仪式召唤效果。会默认把 code1 添加到 c 的 codelist
code1 为仪式怪兽卡号，素材的仪式等级之和要 刚好 大于或者等于仪式怪兽的原本等级
summon_location 表示从哪里仪式召唤(默认是手卡)
grave_filter 表示 作为解放代替除外墓地  的仪式素材需要满足的条件
mat_filter 表示仪式素材要满足的条件
等价于：
	aux.AddCodeList(c,code1)
	aux.AddRitualProcGreater(c,aux.FilterBoolFunction(Card.IsCode,code1),summon_location,grave_filter,mat_filter)

●void aux.AddRitualProcEqual(Card c, function filter, int summon_location=LOCATION_HAND, function grave_filter, function mat_filter)
为卡片 c 添加仪式召唤效果
filter 为仪式怪兽满足的条件，素材的仪式等级之和必须等于仪式怪兽的原本等级
summon_location 表示从哪里仪式召唤(默认是手卡)
grave_filter 表示 作为解放代替除外墓地  的仪式素材需要满足的条件
mat_filter 表示仪式素材要满足的条件
等价于：aux.AddRitualProcUltimate(c,filter,Card.GetOriginalLevel,"Equal",summon_location,grave_filter,mat_filter)

●void aux.AddRitualProcEqualCode(Card c, int code1, int summon_location=LOCATION_HAND, function grave_filter, function mat_filter)
为卡片 c 添加仪式召唤效果
code1 为仪式怪兽卡号，素材的仪式等级之和必须等于仪式怪兽的原本等级
summon_location 表示从哪里仪式召唤(默认是手卡)
grave_filter 表示 作为解放代替除外墓地  的仪式素材需要满足的条件
mat_filter 表示仪式素材要满足的条件
等价于：
	aux.AddCodeList(c,code1)
	aux.AddRitualProcEqual(c,aux.FilterBoolFunction(Card.IsCode,code1),summon_location,grave_filter,mat_filter)

●void aux.AddRitualProcEqual2(Card c, function filter, int summon_location=LOCATION_HAND, function grave_filter, function mat_filter)
为卡片 c 添加仪式召唤效果
filter 为仪式怪兽满足的条件，素材的仪式等级之和必须等于仪式怪兽的等级(此等级可能会因为其他卡效果改变)
summon_location 表示从哪里仪式召唤(默认是手卡)
grave_filter 表示 作为解放代替除外墓地  的仪式素材需要满足的条件
mat_filter 表示仪式素材要满足的条件
等价于：aux.AddRitualProcUltimate(c,filter,Card.GetLevel,"Equal",summon_location,grave_filter,mat_filter)

●void aux.AddRitualProcEqual2Code(Card c, int code1, int summon_location=LOCATION_HAND, function grave_filter, function mat_filter)
为卡片 c 添加仪式召唤效果
code1 为仪式怪兽卡号，素材的等级之和必须等于仪式怪兽的等级(此等级可能会因为其他卡效果改变)
summon_location 表示从哪里仪式召唤(默认是手卡)
grave_filter 表示 作为解放代替除外墓地  的仪式素材需要满足的条件
mat_filter 表示仪式素材要满足的条件
等价于：
	aux.AddCodeList(c,code1)
	aux.AddRitualProcEqual2(c,aux.FilterBoolFunction(Card.IsCode,code1),summon_location,grave_filter,mat_filter)

●void aux.AddRitualProcEqual2Code2(Card c, int code1, int code2, int summon_location=LOCATION_HAND, function grave_filter, function mat_filter)
为卡片 c 添加仪式召唤手续
code1,code2 为仪式怪兽卡号，素材的等级之和必须等于仪式怪兽的等级(此等级可能会因为其他卡效果改变)
summon_location 表示从哪里仪式召唤(默认是手卡)
grave_filter 表示 作为解放代替除外墓地  的仪式素材需要满足的条件
mat_filter 表示仪式素材要满足的条件
等价于：
	aux.AddCodeList(c,code1,code2)
	aux.AddRitualProcEqual2(c,aux.FilterBoolFunction(Card.IsCode,code1,code2),summon_location,grave_filter,mat_filter)

●void aux.AddRitualProcGreater2(Card c, function filter, int summon_location=LOCATION_HAND, function grave_filter, function mat_filter)
为卡片 c 添加仪式召唤手续
filter 为仪式怪兽满足的条件，素材的仪式等级之和要 刚好 大于或者等于仪式怪兽的等级(此等级可能会因为其他卡效果改变)
summon_location 表示从哪里仪式召唤(默认是手卡)
grave_filter 表示 作为解放代替除外墓地  的仪式素材需要满足的条件
mat_filter 表示仪式素材要满足的条件
等价于：aux.AddRitualProcUltimate(c,filter,Card.GetLevel,"Equal",summon_location,grave_filter,mat_filter)

●void aux.AddRitualProcGreater2Code(Card c, int code1, int summon_location=LOCATION_HAND, function grave_filter, function mat_filter)
为卡片 c 添加仪式召唤手续
code1 为仪式怪兽卡号，素材的仪式等级之和要 刚好 大于或者等于仪式怪兽的等级(此等级可能会因为其他卡效果改变)
summon_location 表示从哪里仪式召唤(默认是手卡)
grave_filter 表示 作为解放代替除外墓地  的仪式素材需要满足的条件
mat_filter 表示仪式素材要满足的条件
等价于：
	aux.AddCodeList(c,code1)
	aux.AddRitualProcGreater2(c,aux.FilterBoolFunction(Card.IsCode,code1),Card.GetLevel,"Equal",summon_location,grave_filter,mat_filter)

●void aux.AddRitualProcGreater2Code2(Card c, int code1, int code2, int summon_location=LOCATION_HAND, function grave_filter, function mat_filter)
为卡片 c 添加仪式召唤手续
code1,code2 为仪式怪兽卡号，素材的仪式等级之和要 刚好 大于或者等于仪式怪兽的等级(此等级可能会因为其他卡效果改变)
summon_location 表示从哪里仪式召唤(默认是手卡)
grave_filter 表示 作为解放代替除外墓地  的仪式素材需要满足的条件
mat_filter 表示仪式素材要满足的条件
等价于：
	aux.AddCodeList(c,code1,code2)
	aux.AddRitualProcGreater2(c,aux.FilterBoolFunction(Card.IsCode,code1,code2),Card.GetLevel,"Equal",summon_location,grave_filter,mat_filter)

●void aux.EnablePendulumAttribute(Card c[, bool active_effect=true])
为灵摆怪兽 c 添加灵摆怪兽属性（灵摆召唤，灵摆卡的发动）
active_effect==false 则不注册灵摆卡“卡的发动”的效果

●void aux.EnableReviveLimitPendulumSummonable(Card c[, int location=0xff])
如果 怪兽 c 从 location 灵摆召唤，也能解除苏生限制(?) (超天新龙 异色眼革命龙 (16306932))

●void aux.AddLinkProcedure(Card c, function f|nil, int minc[, int maxc=99, function gf|nil])
为卡片 c 添加连接召唤手续
用 minc-maxc 个满足过滤条件 f [的卡片组里满足过滤条件 gf ]的怪兽作为连接素材
gf 原型为：
function gf(Group g)

●int aux.GetLinkCount(Card c)
返回卡片 c 作为连接素材时当做的素材数量
function aux.GetLinkCount(c)
	if c:IsType(TYPE_LINK) and c:GetLink()>1 then
		return 1+0x10000*c:GetLink()
	else return 1 end
end

●Group aux.GetLinkMaterials(int tp, function filter, Card lc)
获取玩家 tp 的 LOCATION_MZONE 里满足条件 f 的能作为卡片 lc 的连接素材的卡片组

●void aux.EnableExtraDeckSummonCountLimit()
打开额外卡组召唤的数量限制， 数量为1。并注册了一个全局效果 (?)

●bool aux.AddMaterialCodeList(Card c, int code[, ...])
检测 c 是否是有卡名 code[, ...] 为素材的卡

●bool aux.IsMaterialListCode(Card c, int code)
检测 c 是否是有卡名 code 为素材的卡
function aux.IsMaterialListCode(c,code)
	return c.material and c.material[code]
end

●bool aux.IsMaterialListSetCard(Card c, int setcode)
检测 c 是否是有字段 setcode 为素材的卡
function aux.IsMaterialListSetCard(c,setcode)
	if not c.material_setcode then return false end
	if type(c.material_setcode)=='table' then
		for i,scode in ipairs(c.material_setcode) do
			if setcode&0xfff==scode&0xfff and setcode&scode==setcode then return true end
		end
	else
		return setcode&0xfff==c.material_setcode&0xfff and setcode&c.material_setcode==setcode
	end
	return false
end

●bool aux.IsMaterialListType(Card c, any ctype)
检测 c 是否是有类型 ctype 为素材的卡
function aux.IsMaterialListType(c,type)
	return c.material_type and type&c.material_type==type
end

●void aux.AddCodeList(Card c, int code1[, ...])
为卡片 c 添加卡名记述 code1[, ...]

●bool aux.IsCodeListed(Card c, int code)
检测 c 是否是有卡名 code 记述的卡

●bool aux.IsCounterAdded(Card c, int counter)
检测 c 是否添加了指示物 counter (?)

●bool aux.IsInGroup(Card c, Group g)
function aux.IsInGroup(c,g)
	return g:IsContains(c)
end

●int aux.GetColumn(Card c, int player=0)
返回以 player 来看的卡片 c 所在的那一列的序号，不包含 场地区域，从左到右 分别是 0~4

●int aux.MZoneSequence(int seq)
返回 seq 是第几列怪兽区，从左到右 分别是 0~4 ,若在 额外怪兽区，则返回 左 1 或者 右 3 

●int aux.SZoneSequence(int seq)
返回 seq 是第几列魔陷区，从左到右 分别是 0~4 ,不包含场地区

●int aux.ChangeBattleDamage(int player, int value)
如果 player 是受到战斗伤害的玩家，则改变战斗伤害为 value

●bool aux.disfilter1(Card c)
检测是否是 可以被无效效果的 怪兽
function aux.disfilter1(c)
	return c:IsFaceup() and not c:IsDisabled() and (not c:IsType(TYPE_NORMAL) or c:GetOriginalType()&TYPE_EFFECT~=0)
end

●bool aux.bdcon(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)
检测 e:GetHandler() 是否和本次战斗有关，通常用于 EVENT_BATTLE_DESTROYING 的 condition
function aux.bdcon(e,tp,eg,ep,ev,re,r,rp)
	local c=e:GetHandler()
	return c:IsRelateToBattle()
end

●bool aux.bdocon(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)
检测 e:GetHandler() 是否和本次战斗有关，通常用于 EVENT_BATTLE_DESTROYING,并且是与对方怪兽战斗 的 condition
function aux.bdocon(e,tp,eg,ep,ev,re,r,rp)
	local c=e:GetHandler()
	return c:IsRelateToBattle() and c:IsStatus(STATUS_OPPO_BATTLE)
end

●bool aux.bdgcon(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)
检测 e:GetHandler() 是否和本次战斗有关，通常用于 EVENT_BATTLE_DESTROYING,并且战斗破坏对方怪兽送去墓地 的 condition
function aux.bdgcon(e,tp,eg,ep,ev,re,r,rp)
	local c=e:GetHandler()
	local bc=c:GetBattleTarget()
	return c:IsRelateToBattle() and bc:IsLocation(LOCATION_GRAVE) and bc:IsType(TYPE_MONSTER)
end

●bool aux.bdogcon(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)
检测 e:GetHandler() 是否和本次战斗有关，通常用于 EVENT_BATTLE_DESTROYING,并且是攻击对方怪兽并战斗破坏对方怪兽送去墓地 的 condition
function aux.bdogcon(e,tp,eg,ep,ev,re,r,rp)
	local c=e:GetHandler()
	local bc=c:GetBattleTarget()
	return c:IsRelateToBattle() and c:IsStatus(STATUS_OPPO_BATTLE) and bc:IsLocation(LOCATION_GRAVE) and bc:IsType(TYPE_MONSTER)
end

●bool aux.dogcon(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)
检测 e:GetHandler() 是否是被对方破坏送去墓地 SetCondition
function aux.dogcon(e,tp,eg,ep,ev,re,r,rp)
	local c=e:GetHandler()
	return c:GetPreviousControler()==tp and c:IsReason(REASON_DESTROY) and rp==1-tp
end

●bool aux.dogfcon(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)
检测 e:GetHandler() 是否是从自己场上被对方破坏送去墓地 SetCondition
function aux.dogfcon(e,tp,eg,ep,ev,re,r,rp)
	local c=e:GetHandler()
	return c:IsPreviousLocation(LOCATION_ONFIELD) and c:GetPreviousControler()==tp
		and c:IsReason(REASON_DESTROY) and rp==1-tp
end

●bool aux.exccon(Effect e)
这张卡送去墓地的回合 不能发动这个效果 的简单写法 SetCondition
function aux.exccon(e)
	return Duel.GetTurnCount()~=e:GetHandler():GetTurnID() or e:GetHandler():IsReason(REASON_RETURN)
end

●bool aux.bpcon(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)
检测 能否进入战斗阶段 或者 是否已经在战斗阶段内 的简单写法 SetCondition
function aux.bpcon(e,tp,eg,ep,ev,re,r,rp)
	return Duel.IsAbleToEnterBP() or (Duel.GetCurrentPhase()>=PHASE_BATTLE_START and Duel.GetCurrentPhase()<=PHASE_BATTLE)
end

●bool aux.dscon(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)
检测 不是伤害阶段 或者 不是已经进行过伤害计算 的简单写法 SetCondition
function aux.dscon(e,tp,eg,ep,ev,re,r,rp)
	return Duel.GetCurrentPhase()~=PHASE_DAMAGE or not Duel.IsDamageCalculated()
end

●bool aux.chainreg(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)
死亡魔导龙(81059524)用了此函数，用于 SetOperation ，其实就是相当于
function aux.chainreg(e,tp,eg,ep,ev,re,r,rp)
	if e:GetHandler():GetFlagEffect(1)==0 then
		e:GetHandler():RegisterFlagEffect(1,RESET_EVENT+RESETS_STANDARD-RESET_TURN_SET+RESET_CHAIN,0,1)
	end
end

●bool aux.imval1(Effect e, Card c)
c不是免疫效果 e 的过滤函数的简单写法，用在效果注册里 SetValue
--default filter for EFFECT_CANNOT_BE_BATTLE_TARGET
function aux.imval1(e,c)
	return not c:IsImmuneToEffect(e)
end

●bool aux.indsval(Effect e, Effect re, int rp)
如果 reason_player 是这张卡的控制者(一般是自己)则…… 的过滤函数的简单写法，用在效果注册里 SetValue
--filter for EFFECT_INDESTRUCTABLE_EFFECT + self
function aux.indsval(e,re,rp)
	return rp==e:GetHandlerPlayer()
end

●bool aux.indoval(Effect e, Effect re, int rp)
如果 reason_player 不是这张卡的控制者(一般是对方)则…… 的过滤函数的简单写法，用在效果注册里 SetValue
--filter for EFFECT_INDESTRUCTABLE_EFFECT + opponent
function aux.indoval(e,re,rp)
	return rp==1-e:GetHandlerPlayer()
end

●bool aux.tgsval(Effect e, Effect re, int rp)
如果 reason_player 是这张卡的控制者(一般是自己)则…… 的过滤函数的简单写法，用在效果注册里 SetValue
--filter for EFFECT_CANNOT_BE_EFFECT_TARGET + self
function aux.tgsval(e,re,rp)
	return rp==e:GetHandlerPlayer()
end

●bool aux.tgoval(Effect e, Effect re, int rp)
如果 reason_player 不是这张卡的控制者(一般是对方)则…… 的过滤函数的简单写法，用在效果注册里 SetValue
--filter for EFFECT_CANNOT_BE_EFFECT_TARGET + opponent
function aux.tgoval(e,re,rp)
	return rp==1-e:GetHandlerPlayer()
end

●bool aux.nzatk(Card c)
攻击力不为0的表侧表示的怪兽的过滤函数的简单写法
function aux.nzatk(c)
	return c:IsFaceup() and c:GetAttack()>0
end

●bool aux.nzdef(Card c)
守备力不为0的表侧表示的怪兽的过滤函数的简单写法
function aux.nzdef(c)
	return c:IsFaceup() and c:GetDefense()>0
end

●bool aux.sumreg(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)
妖仙兽 阎魔巳裂(39853199)和一些其他卡(49249907,93368494)用了此函数，就是注册一个flag，其实就是相当于
function aux.sumreg(e,tp,eg,ep,ev,re,r,rp)
	local tc=eg:GetFirst()
	local code=e:GetLabel()
	while tc do
		if tc:GetOriginalCode()==code then
			tc:RegisterFlagEffect(code,RESET_EVENT+0x1ec0000+RESET_PHASE+PHASE_END,0,1)
		end
		tc=eg:GetNext()
	end
end

●bool aux.fuslimit(Effect e, Effect se, int sp, int st)
不能用 融合召唤 以外的方式召唤(广义的) 的过滤函数的简单写法，用在效果注册里 SetValue
se 指召唤这张卡的效果， sp 是召唤的玩家， st 是召唤的类型
function aux.fuslimit(e,se,sp,st)
	return st&SUMMON_TYPE_FUSION==SUMMON_TYPE_FUSION
end

●bool aux.ritlimit(Effect e, Effect se, int sp, int st)
不能用 仪式召唤 以外的方式召唤(广义的) 的过滤函数的简单写法，用在效果注册里 SetValue
se 指召唤这张卡的效果， sp 是召唤的玩家， st 是召唤的类型
function aux.ritlimit(e,se,sp,st)
	return st&SUMMON_TYPE_RITUAL==SUMMON_TYPE_RITUAL
end

●bool aux.synlimit(Effect e, Effect se, int sp, int st)
不能用 同调召唤 以外的方式召唤(广义的) 的过滤函数的简单写法，用在效果注册里 SetValue
se 指召唤这张卡的效果， sp 是召唤的玩家， st 是召唤的类型
function aux.synlimit(e,se,sp,st)
	return st&SUMMON_TYPE_SYNCHRO==SUMMON_TYPE_SYNCHRO
end

●bool aux.xyzlimit(Effect e, Effect se, int sp, int st)
不能用 超量召唤 以外的方式召唤(广义的) 的过滤函数的简单写法，用在效果注册里 SetValue
se 指召唤这张卡的效果， sp 是召唤的玩家， st 是召唤的类型
function aux.xyzlimit(e,se,sp,st)
	return st&SUMMON_TYPE_XYZ==SUMMON_TYPE_XYZ
end

●bool aux.penlimit(Effect e, Effect se, int sp, int st)
不能用 灵摆召唤 以外的方式召唤(广义的) 的过滤函数的简单写法，用在效果注册里 SetValue
se 指召唤这张卡的效果， sp 是召唤的玩家， st 是召唤的类型
function aux.penlimit(e,se,sp,st)
	return st&SUMMON_TYPE_PENDULUM==SUMMON_TYPE_PENDULUM
end

●bool aux.linklimit(Effect e, Effect se, int sp, int st)
不能用 连接召唤 以外的方式召唤(广义的) 的过滤函数的简单写法，用在效果注册里 SetValue
se 指召唤这张卡的效果， sp 是召唤的玩家， st 是召唤的类型
function aux.linklimit(e,se,sp,st)
	return st&SUMMON_TYPE_LINK==SUMMON_TYPE_LINK
end

●bool aux.damcon1(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)
玩家 tp 受到伤害 这个条件的简单写法，，用在效果注册里 SetCondition
function aux.damcon1(e,tp,eg,ep,ev,re,r,rp)
	local e1=Duel.IsPlayerAffectedByEffect(tp,EFFECT_REVERSE_DAMAGE)
	local e2=Duel.IsPlayerAffectedByEffect(tp,EFFECT_REVERSE_RECOVER)
	local rd=e1 and not e2
	local rr=not e1 and e2
	local ex,cg,ct,cp,cv=Duel.GetOperationInfo(ev,CATEGORY_DAMAGE)
	if ex and (cp==tp or cp==PLAYER_ALL) and not rd and not Duel.IsPlayerAffectedByEffect(tp,EFFECT_NO_EFFECT_DAMAGE) then
		return true
	end
	ex,cg,ct,cp,cv=Duel.GetOperationInfo(ev,CATEGORY_RECOVER)
	return ex and (cp==tp or cp==PLAYER_ALL) and rr and not Duel.IsPlayerAffectedByEffect(tp,EFFECT_NO_EFFECT_DAMAGE)
end

●bool aux.qlifilter(Effect e, Effect te)
机壳怪兽通用抗性(不受原本等级·阶级比这张卡等级低的怪兽效果影响)的过滤函数的简单写法，用在效果注册里 SetValue
te 是 将要影响到 e:GetHandler() 的效果
function aux.qlifilter(e,te)
	if te:IsActiveType(TYPE_MONSTER) and te:IsActivated() then
		local lv=e:GetHandler():GetLevel()
		local ec=te:GetOwner()
		if ec:IsType(TYPE_LINK) then
			return false
		elseif ec:IsType(TYPE_XYZ) then
			return ec:GetOriginalRank()<lv
		else
			return ec:GetOriginalLevel()<lv
		end
	else
		return false
	end
end

●bool aux.gbspcon(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)
剑斗兽通用效果(用「剑斗兽」怪兽的效果特殊召唤)的过滤条件的简单写法，用在效果注册里 SetCondition
2619149,4253484,31247589,42592719,65984457,78868776,  虽然写法不同，但是没问题
function aux.gbspcon(e,tp,eg,ep,ev,re,r,rp)
	local st=e:GetHandler():GetSummonType()
	return st&SUMMON_VALUE_GLADIATOR>0
end

●bool aux.evospcon(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp)
进化龙通用效果(用「进化虫」怪兽的效果特殊召唤)的过滤条件的简单写法，用在效果注册里 SetCondition
function aux.evospcon(e,tp,eg,ep,ev,re,r,rp)
	local st=e:GetHandler():GetSummonType()
	return st&SUMMON_VALUE_EVOLTILE>0
end

●function aux.NecroValleyFilter(function f)
根据过滤条件f返回一个新的过滤条件：满足f并且没有受王家长眠之谷的影响且不会被无效连锁的卡
function aux.NecroValleyFilter(f)
	return	function(target,...)
				return f(target,...) and not (target:IsHasEffect(EFFECT_NECRO_VALLEY) and Duel.IsChainDisablable(0))
			end
end

●function aux.AddUrsarcticSpSummonEffect(Card c)
主卡6只北极天熊自身①效果的效果注册

●function aux.AtkEqualsDef(Card c)
怪兽区的 攻击力与守备力相同的怪兽 的过滤条件

●bool aux.bfgcost(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp, int chk)
把这张卡除外 的过滤条件的简单写法，，用在效果注册的 cost 里
function aux.bfgcost(e,tp,eg,ep,ev,re,r,rp,chk)
	if chk==0 then return e:GetHandler():IsAbleToRemoveAsCost() end
	Duel.Remove(e:GetHandler(),POS_FACEUP,REASON_COST)
end

●bool aux.dncheck(Group g)
检测卡片组 g 中是否有同名卡的简单写法，返回值如果为 true 表示没有同名卡
function aux.dncheck(g)
	return g:GetClassCount(Card.GetCode)==#g
end

●bool aux.dlvcheck(Group g)
检测卡片组 g 中是否有相同等级的卡的简单写法，返回值如果为 true 表示没有相同等级卡
function aux.dlvcheck(g)
	return g:GetClassCount(Card.GetLevel)==#g
end

●bool aux.drkcheck(Group g)
检测卡片组 g 中是否有相同阶级的卡的简单写法，返回值如果为 true 表示没有相同阶级卡
function aux.drkcheck(g)
	return g:GetClassCount(Card.GetRank)==#g
end

●bool aux.dlkcheck(Group g)
检测卡片组 g 中是否有相同连接值的卡的简单写法，返回值如果为 true 表示没有相同连接值卡
function aux.dlkcheck(g)
	return g:GetClassCount(Card.GetLink)==#g
end

●bool aux.dabcheck(Group g)
检测卡片组 g 中是否有相同属性的卡的简单写法，返回值如果为 true 表示没有相同属性卡
function aux.dabcheck(g)
	return g:GetClassCount(Card.GetAttribute)==#g
end

●bool aux.drccheck(Group g)
检测卡片组 g 中是否有相同种族的卡的简单写法，返回值如果为 true 表示没有相同种族卡
function aux.drccheck(g)
	return g:GetClassCount(Card.GetRace)==#g
end

●bool aux.gfcheck(Group g, function f, any a1, any a2)
检测 g 中的卡是否是满足过滤条件是 f 并且参数分别是 a1 和 a2 的2张卡。若 g 里的卡的数量不是2，则返回false
function aux.gfcheck(g,f,a1,a2)
	if #g~=2 then return false end
	local c1=g:GetFirst()
	local c2=g:GetNext()
	return f(c1,a1) and f(c2,a2) or f(c2,a1) and f(c1,a2)
end

●bool aux.gffcheck(Group g, function f1, any a1, function f2, any a2)
检测 g 中的卡是否是满足1张卡过滤条件是 f1，另1张卡的过滤条件是f2， 并且参数分别是 a1 和 a2 的2张卡。若 g 里的卡的数量不是2，则返回false
function aux.gffcheck(g,f1,a1,f2,a2)
	if #g~=2 then return false end
	local c1=g:GetFirst()
	local c2=g:GetNext()
	return f1(c1,a1) and f2(c2,a2) or f1(c2,a1) and f2(c1,a2)
end

●bool aux.mzctcheck(Group g, int tp)
检测玩家 tp 场上是否有卡片组 g 离开后可用的主要怪兽区格子 的简单写法
function aux.mzctcheck(g,tp)
	return Duel.GetMZoneCount(tp,g)>0
end

●bool aux.mzctcheckrel(Group g, int tp)
检测玩家 tp 场上是否有卡片组 g 离开后可用的主要怪兽区格子，并且检测卡片组 g 能否解放 的简单写法
function aux.mzctcheckrel(g,tp)
	return Duel.GetMZoneCount(tp,g)>0 and Duel.CheckReleaseGroup(tp,aux.IsInGroup,#g,nil,g)
end

●bool aux.ExceptThisCard(Effect e)
若 e:GetHandler() 与效果 e 有联系，则返回 e:GetHandler() ,否则返回 nil 。就是 这张卡以外 的简单写法，用在效果注册里
function aux.ExceptThisCard(e)
	local c=e:GetHandler()
	if c:IsRelateToEffect(e) then return c else return nil end
end

●bool aux.GetMultiLinkedZone(int tp)
获取玩家 tp 场上被2个以上链接标记指向的区域。比如那几只守护龙

●void aux.nbcon(int tp, Effect re)
--condition of "negate activation and banish"
function aux.nbcon(tp,re)
	local rc=re:GetHandler()
	return Duel.IsPlayerCanRemove(tp)
		and (not rc:IsRelateToEffect(re) or rc:IsAbleToRemove())
end

●void aux.tdcfop(Card c)
卡片 c 的返回卡组的接触融合的操作函数。如果素材有里侧表示的，会展示
function aux.tdcfop(c)
	return	function(g)
				local cg=g:Filter(Card.IsFacedown,nil)
				if cg:GetCount()>0 then
					Duel.ConfirmCards(1-c:GetControler(),cg)
				end
				Duel.SendtoDeck(g,nil,2,REASON_COST)
			end
end

●void aux.SequenceToGlobal(int player, int loc, int seq)
--return the global index of the zone in (p,loc,seq)
function aux.SequenceToGlobal(p,loc,seq)
	if p~=0 and p~=1 then
		return 0
	end
	if loc==LOCATION_MZONE then
		if seq<=6 then
			return 0x1<<(16*p+seq)
		else
			return 0
		end
	elseif loc == LOCATION_SZONE then
		if seq<=4 then
			return 0x10<<(16*p+seq)
		else
			return 0
		end
	else
		return 0
	end
end

●bool Group.CheckSubGroup(Group g, function f[, int minc=1, int maxc=#g, ...])
检测卡片组 g 中是否存在满足 过滤条件 f，并且数量在 minc-maxc 的子集, 第5个参数开始为额外参数(非常好用的检测子集函数!)
f 的函数原型为
function f(Group sg,...) end

●Group Group.SelectSubGroup(Group g, int tp, function f, bool cancelable, int minc=1, int maxc=#g, ...)
从卡片组 g 中选一个满足 过滤条件 f，并且数量在 minc-maxc 的子集， cancelable 表示是否可以取消操作, 第7个参数开始为额外参数(非常好用的选择子集函数!)
f 的函数原型为
function f(Group sg,...) end

●Group aux.CreateChecks(function f, table list)

function aux.CreateChecks(f,list)
	local checks={}
	for i=1,#list do
		checks[i]=function(c) return f(c,list[i]) end
	end
	return checks
end

●bool aux.CheckGroupRecursiveEach(Card c, Group sg, Group g, function f, table checks, ...)

function aux.CheckGroupRecursiveEach(c,sg,g,f,checks,ext_params)
	if not checks[1+#sg](c) then
		return false
	end
	sg:AddCard(c)
	if aux.GCheckAdditional and not aux.GCheckAdditional(sg,c,g,f,min,max,ext_params) then
		sg:RemoveCard(c)
		return false
	end
	local res
	if #sg==#checks then
		res=f(sg,table.unpack(ext_params))
	else
		res=g:IsExists(aux.CheckGroupRecursiveEach,1,sg,sg,g,f,checks,ext_params)
	end
	sg:RemoveCard(c)
	return res
end

●bool Group.CheckSubGroupEach(Group g, table checks, function f, ...)

function Group.CheckSubGroupEach(g,checks,f,...)
	if f==nil then f=aux.TRUE end
	if #g<#checks then return false end
	local ext_params={...}
	local sg=Group.CreateGroup()
	return g:IsExists(aux.CheckGroupRecursiveEach,1,sg,sg,g,f,checks,ext_params)
end

●Group Group.SelectSubGroupEach(Group g, int tp, table checks, bool cancelable, function f, ...)

function Group.SelectSubGroupEach(g,tp,checks,cancelable,f,...)
	if cancelable==nil then cancelable=false end
	if f==nil then f=aux.TRUE end
	local ct=#checks
	local ext_params={...}
	local sg=Group.CreateGroup()
	local finish=false
	while #sg<ct do
		local cg=g:Filter(aux.CheckGroupRecursiveEach,sg,sg,g,f,checks,ext_params)
		if #cg==0 then break end
		local tc=cg:SelectUnselect(sg,tp,false,cancelable,ct,ct)
		if not tc then break end
		if not sg:IsContains(tc) then
			sg:AddCard(tc)
			if #sg==ct then finish=true end
		else
			sg:Clear()
		end
	end
	if finish then
		return sg
	else
		return nil
	end
end

========== Debug ==========
●void Debug.Message(any msg)
显示消息，可以传入任何类型，最终都会被转为字符串

●Card Debug.AddCard(int code, int owner, int player, int location, int seq, int pos[, bool proc=false])
添加卡片，将卡号为 code 的卡片的持有者设置为 owner，以表示形式 pos 放置在 player 的场上位于 location 上序号为 seq 的格子处
proc==true 则完成正规召唤程序(即解除苏生限制)

●void Debug.SetPlayerInfo(int playerid, int lp, int startcount, int drawcount)
设置玩家信息，基本分为 lp，初始手卡为 startcount 张，每回合抽 drawcount 张
在残局当中， playerid ：自己==0,对方==1

●void Debug.PreSummon(Card c, int sum_type[, int sum_location=0])
设置卡片 c 的召唤信息：以 sum_type 方法(通常召唤、特殊召唤等)[从 sum_location]出场

●bool Debug.PreEquip(Card equip_card, Card target)
为 target 添加装备 equip_card ，返回值表示是否成功

●void Debug.PreSetTarget(Card c, Card target)
把 target 选为卡片 c 的永续对象

●void Debug.PreAddCounter(Card c, int counter_type[, int count=0])
为卡片 c 添加 count 个 counter_type 的指示物

●void Debug.ReloadFieldBegin(int flag[, int rule=3])
以选项flag开始布局
	flag 残局： DUEL_ATTACK_FIRST_TURN+DUEL_SIMPLE_AI
		 大师1规则： DUEL_OBSOLETE_RULING
	rule==4 是新大师规则
	rule==5 是新大师规则2020
	
●void Debug.ReloadFieldEnd()
布局结束, 位于 Debug.ReloadFieldBegin 和 Debug.ReloadFieldEnd 之间的代码才会在开始前被加载

●void Debug.SetAIName(string name)
设置AI的名字，最大长度 100 个字符（1个汉字2个字符）

●void Debug.ShowHint(string msg)
显示消息提示框，最大长度 1024 个字符（1个汉字2个字符）
